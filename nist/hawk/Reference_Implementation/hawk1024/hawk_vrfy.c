#include "hawk_inner.h"

/* ==================================================================== */
/*
 * Modular integers.
 * Modulus is p such that:
 *   p-1 is a multiple of 2048
 *   3*2^29 < p < 2^31
 * Montgomery representation of x is x*R mod p with R = 2^32.
 * Values are kept in the [0..p-1] range.
 *
 * The key pair generation implementation uses very similar functions;
 * here, we will use them for exactly two moduli: 2147473409 and 2147389441.
 */

static inline uint32_t
mp_add(uint32_t a, uint32_t b, uint32_t p)
{
	uint32_t d = a + b - p;
	return d + (p & tbmask(d));
}

static inline uint32_t
mp_sub(uint32_t a, uint32_t b, uint32_t p)
{
	uint32_t d = a - b;
	return d + (p & tbmask(d));
}

static inline uint32_t
mp_montymul(uint32_t a, uint32_t b, uint32_t p, uint32_t p0i)
{
	uint64_t z = (uint64_t)a * (uint64_t)b;
	uint32_t w = (uint32_t)z * p0i;
	uint32_t d = (uint32_t)((z + (uint64_t)w * (uint64_t)p) >> 32) - p;
	return d + (p & tbmask(d));
}

/*
 * Return (u*f - v*g)/R mod p
 * f and g are provided as uint32_t but there are signed value (at most
 * 2^30 in absolute value).
 */
static inline uint32_t
mp_lin(uint32_t u, uint32_t v, uint32_t f, uint32_t g, uint32_t p, uint32_t p0i)
{
	uint32_t sf = tbmask(f);
	f = (f ^ sf) - sf;
	uint32_t sg = tbmask(g);
	g = (g ^ sg) - sg;

	/* We can do a simpler conditional negation because Montgomery
	   reduction works over values up to p*2^32, so we can allow
	   intermediate values to go up to p. */
	u += sf & (p - (u << 1));
	v += sg & (p - (v << 1));
	return mp_sub(mp_montymul(u, f, p, p0i), mp_montymul(v, g, p, p0i), p);
}

/*
 * Division: return x/y mod p.
 * Parameter m16 is the Montgomery representation of 16 (i.e. 16*R mod p).
 */
static uint32_t
mp_div(uint32_t x, uint32_t y, uint32_t p, uint32_t p0i, uint32_t m16)
{
	/*
	 * Binary GCD between y and p:
	 * Init:
	 *    a <- y
	 *    b <- p
	 *    u <- x
	 *    v <- 0
	 * Invariants:
	 *    a*x = u*y mod p
	 *    b*x = v*y mod p
	 *    b is odd
	 * Operations:
	 *    if a is odd:
	 *        if a > b:
	 *            (a, b, u, v) <- (b, a, v, u)
	 *        (a, u) <- (a - b, u - v mod p)
	 *    (a, u) <- (a/2, u/2 mod p)
	 * Since p < 2^31, we always reach b = 1 in at most 60 iterations
	 * (unless y = 0, in which case b remains equal to p). Then, we
	 * have v = x/y mod p.
	 * Updates to u and v are delayed: they are accumulated in "update
	 * factors" (f0, g0, f1 and g1) and applied every 30 iterations.
	 * Moreover, the update factors are themselves held by pairs: we
	 * can do 15 iterations with f0 and g0 in the same 32-bit variable
	 * (and the same for f1 and g1).
	 */
	uint32_t a = y;
	uint32_t b = p;
	uint32_t u = x;
	uint32_t v = 0;
	uint32_t af0 = 0;
	uint32_t ag0 = 0;
	uint32_t af1 = 0;
	uint32_t ag1 = 0;
	for (int i = 0; i < 4; i ++) {
		uint32_t fg0 = (uint32_t)1;
		uint32_t fg1 = (uint32_t)1 << 16;
		for (int j = 0; j < 15; j ++) {
			uint32_t a_odd = -(a & 1);
			uint32_t swap = tbmask(a - b) & a_odd;
			uint32_t t1 = swap & (a ^ b);
			a ^= t1;
			b ^= t1;
			uint32_t t2 = swap & (fg0 ^ fg1);
			fg0 ^= t2;
			fg1 ^= t2;
			a -= a_odd & b;
			fg0 -= a_odd & fg1;
			a >>= 1;
			fg1 <<= 1;
		}
		fg0 += 0x7FFF7FFF;
		fg1 += 0x7FFF7FFF;
		uint32_t f0 = (fg0 & 0xFFFF) - (uint32_t)0x7FFF;
		uint32_t g0 = (uint32_t)0x7FFF - (fg0 >> 16);
		uint32_t f1 = (fg1 & 0xFFFF) - (uint32_t)0x7FFF;
		uint32_t g1 = (uint32_t)0x7FFF - (fg1 >> 16);

		/*
		 * We apply update factors only once every two outer
		 * iterations. af0, ag0... are the factors from the
		 * previous round. The aggregate factors (for two rounds)
		 * are thus:
		 *   bf0 = af0*f0 - af1*g0
		 *   bg0 = ag0*f0 - ag1*g0
		 *   bf1 = af0*f1 - af1*g1
		 *   bg1 = ag0*f1 - ag1*g1
		 * The aggregate update factors are, in fact, exactly the
		 * value we would obtain from running 30 inner iterations,
		 * so they follow the rules explained in:
		 *    https://eprint.iacr.org/2020/972
		 * In particular, these factors are at most 2^30 in
		 * absolute value. Thus, they do not overflow and we can
		 * use them with mp_lin().
		 */

		if ((i & 1) == 0) {
			af0 = f0;
			ag0 = g0;
			af1 = f1;
			ag1 = g1;
		} else {
			uint32_t bf0 = af0*f0 - af1*g0;
			uint32_t bg0 = ag0*f0 - ag1*g0;
			uint32_t bf1 = af0*f1 - af1*g1;
			uint32_t bg1 = ag0*f1 - ag1*g1;
			uint32_t nu = mp_lin(u, v, bf0, bg0, p, p0i);
			uint32_t nv = mp_lin(u, v, bf1, bg1, p, p0i);
			u = nu;
			v = nv;
		}
	}

	/*
	 * Each inner loop computed the update factors with an implicit
	 * 2^15 factor; two inner iteration lead to a 2^30 factor, but
	 * mp_lin() divided by R = 2^32. In total, we divided by (2^2)^2,
	 * which we must compensate here by multiplying by 16.
	 */
	v = mp_montymul(v, m16, p, p0i);

	/* GCD is in b; it is 1 if and only if y was invertible.
	   Otherwise, the GCD is greater than 1. */
	return v & tbmask(b - 2);
}

/*
 * Assumption: logn >= 3
 */
static void
mp_NTT(unsigned logn, uint32_t *restrict a,
	const uint32_t *restrict gm, uint32_t p, uint32_t p0i)
{
	size_t t = (size_t)1 << logn;
	for (unsigned lm = 0; lm < logn; lm ++) {
		size_t m = (size_t)1 << lm;
		size_t ht = t >> 1;
		size_t v0 = 0;
		for (size_t u = 0; u < m; u ++) {
			uint32_t s = gm[u + m];
			for (size_t v = 0; v < ht; v ++) {
				size_t k1 = v0 + v;
				size_t k2 = k1 + ht;
				uint32_t x1 = a[k1];
				uint32_t x2 = mp_montymul(a[k2], s, p, p0i);
				a[k1] = mp_add(x1, x2, p);
				a[k2] = mp_sub(x1, x2, p);
			}
			v0 += t;
		}
		t = ht;
	}
}

/*
 * This is a variant of mp_NTT, when the source polynomial is auto-adjoint.
 * Only the first n/2 elements of a[] are accessed or modified; the upper
 * n/2 elements are untouched (and need not exist at all in memory).
 *
 * Assumption: logn >= 3
 */
static void
mp_NTT_autoadj(unsigned logn, uint32_t *restrict a,
	const uint32_t *restrict gm, uint32_t p, uint32_t p0i)
{
	size_t hn = (size_t)1 << (logn - 1);
	uint32_t s1 = gm[1];
	size_t qn = hn >> 1;
	for (size_t u = 1; u < qn; u ++) {
		uint32_t x1 = a[u];
		uint32_t x2 = a[hn - u];
		a[u] = mp_sub(x1, mp_montymul(x2, s1, p, p0i), p);
		a[hn - u] = mp_sub(x2, mp_montymul(x1, s1, p, p0i), p);
	}
	a[qn] = mp_sub(a[qn], mp_montymul(a[qn], s1, p, p0i), p);

	size_t t = (size_t)1 << (logn - 1);
	for (unsigned lm = 1; lm < logn; lm ++) {
		size_t m = (size_t)1 << lm;
		size_t ht = t >> 1;
		size_t v0 = 0;
		for (size_t u = 0; u < (m >> 1); u ++) {
			uint32_t s = gm[u + m];
			for (size_t v = 0; v < ht; v ++) {
				size_t k1 = v0 + v;
				size_t k2 = k1 + ht;
				uint32_t x1 = a[k1];
				uint32_t x2 = mp_montymul(a[k2], s, p, p0i);
				a[k1] = mp_add(x1, x2, p);
				a[k2] = mp_sub(x1, x2, p);
			}
			v0 += t;
		}
		t = ht;
	}
}

/*
 * For modulus p:
 *   p0i = -1/p mod 2^32
 *   R2 = 2^64 mod p
 *   R3 = 2^96 mod p
 *   m16 = 16*2^32 mod p
 *   GM[i] = (2^32)*(g^rev(i)) mod p
 * with g being primitive 2048-th root of 1 (i.e. g^1024 = -1 mod p) and
 * rev() being the bit-reversal function over 10 bits.
 * For g, we use s^((p-1)/2048) mod p, where s is the smallest positive
 * integer which is not a quadratic residue modulo p.
 */

#define P1       2147473409
#define P1_0i    2042615807
#define P1_R2     419348484
#define P1_R3    1819566170
#define P1_m16       327648
#define P2       2147389441
#define P2_0i    1862176767
#define P2_R2    1141604340
#define P2_R3     976758995
#define P2_m16      3014624

static const uint32_t GM_p1[] = {
	     20478,  276077475, 1688385698,  761932726, 1138340463, 1021445260,
	 870248807,  829510770, 2071018143,   26820577, 1426496990,  384180207,
	  13882587,  577122007, 1722769540, 1260619389,  904179219, 1933219019,
	2017597084, 1980090712,  851314292, 1881833318, 1050710868,  292816539,
	 889385875,  720685218, 1363110108,  294709449, 1507235110,  863691339,
	1415779453,  577236769, 1356088707,  859867539,  495731206,  347731418,
	2073233829, 2115445737,  254895402,  478229880, 1234534812,  897499182,
	 768652460, 1665656027, 2064969281,  358946764,  613156407, 2057649013,
	 865570366, 1603257950,   93784487, 1555405419,  430242169, 2016636767,
	  15592939, 2063248902,  208260274,   40828442,  865639666, 1846671086,
	 530045817, 1784636572,  434310431, 2034729522,   72005396, 1417019068,
	 760717036, 1499147279, 1074727870, 1621768087,  901308486, 1903420619,
	1374299204, 1561642259,  152372511,  253142775, 1885840122, 1195438051,
	 349011077,  595407623,  937424114, 1675484834, 1009429298,  769141268,
	 617989515,  362418520, 1507272315, 1697181709,  884880928, 1332962991,
	2012484716, 1316703310,  385827688, 1979578328,  336092444, 1222074628,
	2068318345, 1389478811,  614181936,  995572856, 1056612365, 1936377707,
	2047801350,  726552192,  724676777, 1890296365,  634473887,  885891667,
	1117786517,  606908348,  158269774,  349038201,  117167000,  707059113,
	1022519749,  130182295,  572225325, 1832878810, 1546970796, 1401054322,
	 604077445,  476025069,  801284700,  226545108, 1406213035,  361304820,
	1840279680, 1572098519, 1166932694,  871641941,  355203126, 1527038490,
	 920138677,  803717901, 1120014893, 1250819809,  411243131,  133719755,
	1339419901, 1753499439, 1856740559, 1820059845,  627018263,  173517655,
	 263148905, 1225387363, 1647095464, 1789037828, 1237357286,  424234403,
	2022697741, 1993242204,  472346747,  736320822, 1422570303, 2034712410,
	1521115092,   59511560,  233083739, 1071038359,  138044003,  585194459,
	2063546001,   95336925,  122782184, 1241210668,  937341603,   23556949,
	1744406767,  756806207,   27626758, 1670962005,  845043683, 1695011082,
	 291079245, 1426975523,  177745285,  171730410,  894935878,  589703334,
	 368695544, 2146021799, 1998710711, 1625208611, 1038019566, 1735822596,
	1458959865,  536700716,   55127253,   33645590, 1293553947,  519357705,
	1796389440,  532823571,  851537631,  439622598,  701386542,  226984529,
	1900496338, 1359606048, 1300511823, 1878544316, 1917747700, 1219229593,
	 716726745, 1881089376,   60741675, 1617103732, 1964359457, 2069854791,
	 107674061,  686746896,  388509663,  244188980,  929151696,  622041584,
	 414138988,  546275715, 1041130016, 1533321697, 1833810336, 1401193711,
	1907983563, 1051788562, 1422084989,  214049450,   39017815, 2053123362,
	2124366396,  533121484, 1959901195,  319344115, 1217983143, 2126710730,
	 279479502, 2073299949,  146368726,  656585392, 1791775888, 2013070236,
	1117897425, 1457198373,  815373156,  365463730, 1662227660,  507044354,
	1157976583,  375250987, 1229900670, 1117341706,  212929125, 1419915198,
	2132426927, 1671190125, 1711523818,  925978889, 1224002191,  458274263,
	2083360144, 1779032320,  661970963,  453653695,  657293962, 1611752815,
	1541857779, 1668004360, 1064388666, 1596405886, 1308837876, 1290842306,
	 375999699, 1591206728,  688746554,  990123771, 1335220678, 2004995230,
	1113023865,  587323686, 1053377545, 1930726543,  184237055, 1019351378,
	2028012092, 1121557766, 1308820241, 1803419021, 1456239987,  596123337,
	 123299236, 1213294379,  692834991,  577073536,  909039648, 1177323686,
	  89776129,  346566096, 1021398434,   23598762, 1152552592, 1570217184,
	1130049051,  923149110, 1226726700, 2022655059,  325622654,   45265626,
	1041626893, 1936548398,  656976755, 1025242376, 1723768901,  610867220,
	 230825811, 2083697236, 1210403043,   44503338,  864192739, 1564705317,
	 110420908, 1234098582,  304390842,  818465205,  242446514,  350800442,
	1577123608,  670710989,  416747844,  858828029, 1811181248, 2051206439,
	1306395643,  981217938, 1943333004,  300209048, 1621161689,  696476799,
	 915956451,   74087519, 1786333708,  769098576, 1366809333,  626344703,
	1889035632, 1386530081,  866100449, 1862075713,  116818339,   16761336,
	1942776517,  987244652, 2125889249,  619927687, 1285102690, 1928996642,
	1341975713,  196341048, 1023580067,  449780147, 1712401383, 1291972102,
	1311351410, 1751622449, 1810344957, 1427465309, 1998671058,  138319943,
	1539053190,  681335526, 1914088724, 1937041613, 1461731252, 1549542054,
	2057497941,  343265594, 1386029469, 1811074169,   73332584,  967162782,
	1520294965,  528910843, 1614858633,  767170944, 1178765994, 1689360220,
	 570009527,  907400393, 1898713577,  261714461,  321145051, 1990755768,
	1218300312, 1688993883, 1078585155,  595378406, 2144101180, 1883408998,
	  90674327, 1775658489, 1916101296, 1411305669,  355104385,  732871353,
	 906656083, 1852436312, 1679378757, 1671113936, 2042504253,  536576504,
	 497903458, 2117576585, 1525891773,  930467717, 1924508057, 1010032240,
	 858312866,  682057827,  803778033, 1887005062, 1885367618,  825388599,
	1047898330, 1270636295,   40098665, 1052606830, 1574791372, 1296306877,
	1775024299,  704958127, 1901229227,  452149879, 1341693007,  914634230,
	1281018795, 1227927428,    7400504,   78117101, 1400807206, 1572094690,
	1200720226, 1300577167, 1130830146, 1011652166, 1459553519, 1806401605,
	1126824389, 1302351063, 1992416865,   38163005,  503996986,   46983263,
	 930159775, 2120264001,  249287608,  544554228, 1651136098,  278811392,
	  43827035, 2094598565,  136767950,  277580829, 1880905914, 2033552566,
	  86730434,  921540201,  549224603, 1178659383, 1332559691, 1826157172,
	1150267634,  557997259, 1989989449,  909540133, 1819970661, 1540392471,
	2004269739, 2083711935,  279801116,  167487064,  271736710,  828609888,
	 299997693, 1743107346,  892846676,  645477138,  965401638,  870339971,
	1015711103,  723089724,  271389756,  146539013,  675250822, 1693722626,
	 515143301, 2094035615,   19427832, 1502606781,  632939895,  420826764,
	2103115595, 1039935916, 1293980839,  526163207, 1224609315,  849364322,
	 989463231, 1604020817,  780616727, 2036431109, 1509796635, 1159482103,
	 413580819, 1559843409, 1790111537, 1202797834,  117002251, 1144670472,
	1326133417, 1996180806, 1981249647,  614023950, 1675369087,  589303603,
	 909185230, 1439901675,  146330143, 1901025173,   82363662,  624688200,
	1353844204, 1250338764,  388319277, 1504288281,  310072049,  751188341,
	 869587863,   31844112, 1458505756,  811359588,  547528896, 1662753828,
	1247125052, 1769077842, 1243652758, 1192584586, 1843692173, 1368486872,
	1375047202, 1793821540, 1244243154, 2129557563,  319487216, 1845939190,
	1042735899, 1889455632,  667575758, 2062422674, 1847502619,  814568122,
	 909158693,  948432950, 1025400363, 1216549935, 1665672950,  437595396,
	1500648391,  949854479, 1078985562,  721114950, 1454099563,  759799383,
	1046138978,  783748234, 1988568187, 1124904793, 1228513796,  609005725,
	 158401014, 1496088724,  618177510, 2132735259,  970837697, 1584111699,
	1255665028, 1043660987,  178631984, 1126476118, 1766607753, 1506934718,
	 945005486,  518080758, 1920653973,  832808904,  886796275,  298393013,
	1417610475, 2119073318, 1457473075,  680312246, 2077118775,  568187962,
	 632356090, 1153586587,  701570167,  174727464,  438214724,  909063096,
	1083882068, 1929283240,  428330566, 1903048380, 1633931132, 1230298232,
	 838507832, 1399829344, 1800728559, 1114070798,  739540028, 1509915010,
	 291489353, 1487500610,  409385375,  702348742,  745431275, 1193114225,
	1469053117, 1486427244,  141903292,  451606796,  633045416,  519265308,
	1003128400, 1475481540,   84643593,  981144629, 1579759149, 1394930788,
	1616905114, 1865443581,  547830165,  918185560,  589743914,   34076823,
	 600033931, 1217547625,  250480931,  305001212,  498008436,   13087068,
	 554030411, 1144562565,  744723016, 2053213690, 1976419571,  732447240,
	1107697424,  200570586,  297822305,  329269848,  892983345, 1302896585,
	1738952407,  914716774, 1016235154, 1042157012, 1100375860, 1030024078,
	 838660551,   77707346, 1816437515,  112052915, 1533136761,  182333635,
	 620250513,  944653135, 1929778347,   99604862, 1338501791,  497661432,
	 430905130,  101626919,  717940774, 1620557324, 2034911560,  253059400,
	1102076764,  471591502,  844121319, 1630162912, 1210073260, 1827915047,
	1182481947, 1475112556, 1200248030,  416215933,  532885224,   74555155,
	 138497203,  336347601, 1103666447,  798712930,  285734844, 1495879060,
	1053133847,  653062581, 1395120389, 2110517746, 1958384415,   34101643,
	 745928690,  725854416,   36380873,  865483096,  632740760, 1523020547,
	 867794962,  164508864, 1837906739, 1742360155,  237693636, 1329399516,
	1829813931,  131706268, 1106171501,  666344300, 1450762766, 1124426192,
	1012033666,  599621172,  237050852,  606674748,  342655552,   53427652,
	1891601465, 1042612558,  251151473,  860834475,  299567806, 1145685328,
	 268929217, 1930129187, 1726208529, 1686663211,  739517200, 1978593422,
	 877630023, 1963259234, 2024264059,  408759332, 1865619299, 1201317263,
	 368359460,  129979470,  433898878,  663911333,  959850992, 1754304644,
	1725784329, 1563253760, 1844571806,  735499159,  408009966, 1673369135,
	  10151567,  557725073,  702278661, 2031867842, 1262006172,  401708610,
	1498855589, 1377377603,  638953550,  325366876,  597812889,  681948734,
	1650421621,  254734336, 1747384097, 1291543540, 1141026409, 1091610258,
	 392629494, 1708472593, 2102397705, 2043582652, 1768934917,  481998512,
	 988047421, 1723631610,  444279182, 1279863678,  635865792, 1931754710,
	 746566889,  612530185, 1293170492, 1816391575, 1327065362, 1247963721,
	 244167333,  604172859, 1715728363,  126466518, 1003155197,  724002282,
	1497108684, 1259955686,  879208696, 1320207079, 1920501463, 1345760748,
	2070919415, 2069595143, 1349313787,  969943473,  847987463, 1805123632,
	1032472062, 2086424949, 1213527249, 1246853623,  837965912, 2067749933,
	 625152138,   89146939, 1696589581, 1507715632, 1881560996,   13893713,
	 549453266, 1276787275, 1976375304,  340460424,  591815512,  648284075,
	 163257661,  864124470,  704782200,  510870296,  340373961, 1520676335,
	1152412135, 1214083467,  475362314, 1664176279,  627414670,  424650704,
	1716551107,  683659719, 2057746809, 1270950650, 1854042026, 1223757075,
	1856750643,   97340173, 1199409222,  104918287, 1586722213, 1872074540,
	 116978614,  830723457, 1797861576, 1906232791,  652518947,  887210304,
	1706343321,  838773546, 1930389538, 1606048260, 1524272525, 1570448333,
	 242493479,  448828658,  401422089, 1629405374,  898581305, 2011935011,
	 153965010, 1093277618, 1419854975,  743542714,  673328623, 1257330191,
	1125943259,   14645907,  166327009,  130151644,  467028838, 1553116262,
	1293709204, 1485261058, 1773824461, 1323232915, 1586092112,  985286537,
	1422602167,  756632308, 1098844473, 1946260961, 1809471626,  461664429,
	  24238557, 1080828576,   14549292, 1808900612,  592028197,  597697600,
	 844383305, 1346676285,  911563103, 1512308729,   78848577, 1123905571,
	 413530260,  323580692, 1517449176, 1907562715,  388241574, 1612885131,
	 630612412, 1211488241, 1352051177,  812504369, 2116849558, 1079404813,
	 929499315, 2048302692, 1248909687, 1160035325,  709727367, 1076707193,
	1808857706, 1239248699, 2005880575,  988036577,  510264390, 1555654950,
	1784316547,  577021955, 1965524472, 1074915683,  856407927, 1154124024,
	 944344338, 1455525416, 1219394988,   24190940, 1522390293, 1929278133,
	 975753860,  492967930,  632306077,  957837901,  590670101, 1984280579,
	1235150233, 1922371347, 2143499093, 1852491350, 1079172972, 1529986185,
	 390383373,  533692964,  543191472, 1444442805, 1690223550,  130085257,
	1504417556, 1934334110,  236195813,  108960254, 1371149771, 1947385885,
	 403621755,  515851906,  799013576,  461039313,  668590434,  758076422,
	1761115327, 1585803130,  325165043,  757198833,  639697617, 1864574289,
	1038570065, 1955909152,  914185250,  868647112, 1395698776,  468502101,
	1548478888,  799022362, 1508734297,  420027969, 2031373060,  318627896,
	1244553510,  141809776, 2068042335, 1747535105, 1431944840, 1530932574,
	 507373255, 1150760238, 1531282814,  902672318, 2110249730, 1036970955,
	 288573611, 1523839811,  951860614,  341673792, 1425070922,  927375324,
	 374705249,  698002991, 1883310823, 1806010362, 1680777670, 1724191875,
	1047630063, 1458433532, 1161258992, 1361307344
};

static const uint32_t GM_p2[] = {
	    188414,  800844398, 1836298316, 1316983235, 1780194382, 1668674867,
	1876898365,  482608607, 1536539100,  240878826, 2072934951, 1507793182,
	 388886950,  544012720,  623971434, 1537514969,  564156249, 2026329244,
	1169238305, 2116218470, 1755677505,  516332411, 2134172303, 1274742716,
	  10156516,  874196011, 1146980039,  700067736, 1559979991,  472958838,
	1857163854,  430993288, 1554664514, 1127812475,  800590259, 1831017538,
	2085269795, 1190374405,  917848286,  743950221, 1292001292, 1587294613,
	1816925571,  366363604, 1082647155, 1185071803, 1240791685, 1408372324,
	 617500310, 1082289886,   10922647,  153116756, 1920875162,  891503444,
	1432236273,  992755667,  566356501, 2003658946,  498863850, 1423355926,
	1915416518,   41125005,  627808605, 2031299840,  683054160,  644325914,
	 499678143, 1336706381, 1155624913,  994857681, 2032239795, 1992489933,
	 215226666,   34808368, 1909683994,  889515154, 1302078304, 1532709873,
	1366016693, 1601718349, 2022301192, 1587290046, 1937620842,  289781565,
	 222477407,  468803542,  518431148,  294767756, 1499640124,  137663468,
	1614566563,  723325274,  346400867,  520169341, 1560118441, 1256348401,
	 420255414, 2045145768,  445763958, 1957279431, 1089897312, 1823785559,
	1335442474,  628920254,  279364806,  394295299,  964686317,  711507074,
	1690049866, 1206461796,  453690225,  551309632, 1889707476,  181265196,
	 831006161,    5390203, 1031157967,   62957762,  680099046, 1225125850,
	1918370150, 1347691183, 1753907129, 1812471308,  227048573,  593194929,
	 997952947,  583017538, 1440833249, 1325395522,  995751503,  758791449,
	 188172367, 1595490957, 1092692519,  252120048, 1617750316, 1896464617,
	1149396899, 1434711773, 1456425607,  556200145, 1196999469,  856846016,
	1943632162, 1932016102, 1771529939, 2004809953, 1617760120,  312942871,
	 222939007,  211277906,  591793121, 1418587678, 1202513332, 1213649888,
	 484489363,   51967098, 1395106310,  900003303,  567084680, 1790395392,
	2071175318,  780936991, 1752405816,  693637362,  740145789,  650706339,
	 302883486,  148679578,  911686989,  557316307,  336374168, 1903912849,
	 615626314,  490189735, 2032388954,  926592571,  734573505, 1483387521,
	1357349883, 1083511859, 1267428840,  347329879, 1143121434, 1586578240,
	 146861552, 1532495907, 2124987676, 1048532778, 1077266041, 1117086595,
	 689949358, 1068135350,  431710628, 1074622917, 1288317211, 1480936222,
	 180241586,  421417660,  140818127, 1915163045,  123893560, 1737204941,
	 703582550, 1073121055,  378838939, 1926843686, 1047812800,  589279768,
	1457757792, 1247020075, 1639303227,  349300191,  136285747, 1064141730,
	 886451495,  281645262,   59919543,  155276342,   29026456,  325545549,
	 393696585,  579668960,  210745972, 2024600725, 1507975016,  387340488,
	 400206015, 1623761418, 1343456319, 2101574429,  466920733, 1958554927,
	1228886862, 1058433729,  780360398, 1792450489,  900892394, 1258481715,
	 426713499, 1474683970,  131085194, 1939138799, 1028695955,  242084002,
	 140605507, 1877846335, 1100147871,  273096450, 2126409091, 1862069753,
	2111692429, 1530579988,  568291714,  131985840, 1003496155, 1647402985,
	 931560424, 1623282579, 1903389091, 1192494857, 2139778950,  523133012,
	 578148045,  108054268, 1943839217,  779929261,  187567130, 1233240106,
	1826914648,  330785322,  349157420,   11273568, 2088408633, 1245375279,
	1642596731,  445181866,  640222483, 1380727962, 1485344879,  654678981,
	1615857474, 1336203637,  584637099,  411295468, 1885626069, 1260964109,
	 580493593, 1513525322, 1116263926, 1886720168, 2086527716, 1086446753,
	1294031540, 1443688172, 1285013232,  901967352, 1203237258,  939546925,
	1214016639,  409021468, 2043372921, 1058152627,  883390189,  493551388,
	 389568489,  383565368,  397237151,  832432388,  820048426,  885774060,
	 137663796, 2003585073, 1124260993,  783642587, 2088466763,  974201121,
	1211724818,  827383675, 1254109769, 1914948942,  887861792, 2065626072,
	1967830391, 1208676475, 1525588909,   94643456, 1848540735,  842250812,
	1886819651,  876386489, 1748999278,  700527067, 1739374519, 1325228668,
	 160938898, 1232859535, 1908829603,  574230485, 1889039614,  128889256,
	 428580633, 1251143298,  586815366,  983979359,  103683529, 1439527107,
	 975244445, 1618214863, 1045984294,    9203382, 1384966915, 1164922792,
	1508271814, 1347592503,  918789642, 1953875311, 1105947184, 1714608389,
	 990812625,  837908263, 1586123643, 1167580957, 1550318118,  355689451,
	 271669567,  885586853,  309986321, 1878559263, 1030824142,  632062282,
	1758793692, 1032447117,  964851845, 1342498378,  231445866,  342368698,
	 792958440,   34959533,   89135815,  687244446, 2143475638, 1335953248,
	 964487639, 1949598297,  257738458, 1658405004,   87101421,   33866132,
	 516453656,  212513291, 2090783108, 1578188696,  230647921,   22649291,
	1152425856, 1715344274, 1482811363, 1601353271, 1858075840, 2008441088,
	1818203951,   10808313,  431597898,  129507061,   62255403, 1162130477,
	 743767283, 2009648457,   74771973, 1077791439,  640908479,  238871041,
	1369859944,  464263469, 1316249001, 1080490145,  460190380, 1044655799,
	 199560577, 1138794546,  391199045, 1387626260, 2135864202, 1697628854,
	  37177883,  826722236, 1386411384, 1795258277,  798222235, 1950488085,
	1480461342, 1006402752,  263630500,   61953912, 1690738761, 1232533229,
	1065869122, 1162915330,  146088019, 1038903044,  341780976, 2069324444,
	 826050042, 1958502644,  467918430, 1237314953,   36727052,  949489545,
	1665222534,  593996630,  246658931,  902073858, 1582107096,  308217284,
	1071533715,  322297018,  841593029, 1868529972, 1802998967,  670439288,
	1466706083,  453901974, 1596792613,   33614118, 1916038714,  349087247,
	 150500802,  344188537,  752940833,  154697538, 1888514636,  438111364,
	1608203920,  121404176, 2106310373, 1601602748, 2118303190,  683722437,
	1297050626,  176431468, 1707213588,  569841682,  343812661, 1973539602,
	1678694504,  326476685, 1522490240,  394625844, 1937771236, 1945857990,
	1201451834,  421367979,  838341318,  146363541, 1848507395,  145178700,
	1540754890, 1333467727,  720369117,  442317435,  801974167, 1194629469,
	 678922120, 1271864261,  612833486, 1970668877,  643827611, 1343246788,
	 365322845,  129722976,  677655126,  298282875, 1395418115,  284009530,
	 300258726,  399026718,  382510332, 1803732898,  427796945, 1544854479,
	1273559369,  464935884,  258371998,  725494215, 1761446815, 1201466935,
	 181959172, 1672237273,   26156780, 1328760851, 1881115117,  576106112,
	1139428990, 2080590732,  822307267, 1467953565,  110078146,  496358325,
	  19247995, 1542178163,  301142961,  577750067,  203294405,  287043649,
	   6092627,  622602577, 1121594775, 1138213710,  331589734, 1263367198,
	1793090743,  742730233, 1276953771, 1829469791, 1418916595, 1177321925,
	1898312775, 1633701024,  100067957,  519747549,  265226334,  103281107,
	 106997942, 1258408982,  262900075, 1518495250,  250149089, 1763685360,
	 900791668,  753191878, 1679228019, 1812149299,  498846008,  367840055,
	 152352108, 1786131540, 1384348595,  380734937, 1756045385, 2107159067,
	 289895897,  549186096,  451440053, 2100164659,  459526429, 1158297688,
	 640821771,  747017328,  995933539,  544914700, 1540248482, 1884098989,
	 311179263, 1100588606, 1982674278, 1882755543,  673777687,  271104605,
	2112996656, 1564459071, 1518775480, 1975080836, 1332656241, 1952295225,
	 211938949, 1888873510,  706765073, 1456655195,  423910784, 1236384873,
	1654948437,  379578112,   75094808,  698853585, 1980367894, 1103671188,
	 795916535,  961046890, 1361891519, 2013925057, 1671660768,  326777440,
	1473832834, 1007127031, 1610029129, 1188008450,  189894838, 1067709058,
	1766124618, 1884400828, 1830906126, 2131178216, 1918083139, 2111855665,
	 696549428, 1725967527,  423407733,  867627404,  953654908, 1193355515,
	1270957094,   91737545, 2086247014,  249407662, 1088256985, 1413586645,
	1901949274, 1931883585,  706155338,  832639723,   15933097, 1106425007,
	 553766683, 1407756856, 1944121174, 1331469270,  374840113,   25376524,
	1950864447,  657949688,  184584107,  338328461, 1551695475, 1420045117,
	 174566115,  501036435,  457465168, 1031951008,  818194854, 1547192269,
	 947572700,  455728514,  540786346,  884003438,  178693036, 1837084279,
	 869814370,  990185548, 1055549196, 1342116841,  713892792, 1611719604,
	1732566795,  521875044,  965776340,  969170609, 1100900800,  811753482,
	 418934975, 1722802985,   60576544,  433493384, 1935577880,  463071507,
	1041887457, 1099929728, 1415134313, 1497002403, 2015400126, 1837915900,
	1301106554,  490356522, 1310382347,   42962209, 1037764812, 1412492680,
	1153009459, 1321777575,  321401105,  181238904,  439657024,  724065395,
	1062573413, 1406096188, 1692623910, 1496432987,  399504174, 1296871934,
	 947264425, 1731647556, 1689493122,  987552344, 1673420326, 2131557045,
	1033969938,  380648742, 1925832319, 1972106680,  306289979, 2076977586,
	2143619481,  397994526,   82971832, 1339218763, 1209446579,  823539991,
	1095743319,   31300264,  311568081,  308338715, 1973135524, 1738313289,
	  10618949, 1729293984,  656884918,  963056129, 1831720766, 1724329394,
	1473929688,  957670019, 2134652762,  855801569,  337911392, 1384522064,
	 470709300, 1928726766,  681632576, 1515281359,  290264462,  598218076,
	2075693619,  235431420,  313932494,    5935565, 1900122774, 1839972787,
	1031482136, 1584403832,  458068360, 1294765291,  199321555,  958074738,
	 329505910,  390634596,  772851744,  997372950, 1902392406,  911824306,
	 207470906, 1833988394, 1164634858, 2136949384, 1500489452,  867256506,
	1043024124,  273804599,  657638509,  519536539, 1551186589,  736063170,
	1835049310,  274043354,  866615405, 1619589366, 1435976123,  574529072,
	1988345751, 1513180857, 1589623570, 1950816712, 1786479022, 2073192949,
	 498899764,   85596569,  926341728,  643726946, 1723803954, 1595790889,
	1952281981,   15343692, 1963115356,  134007049, 2076842566, 1723273426,
	 737980662, 1914022676,  179895009,   77496865, 1412978837,  884789007,
	1508799456, 1575331823,  173928358,  683913421, 1736847062,  684795030,
	 363617080,  316846537, 1986734606, 1948597245,  463943878,  372293218,
	 633547358,  874650389,  329434973, 2114012866,  555202488, 1839426393,
	 407553052, 1953865482, 1125904531, 1399327136,  831584792, 1266486934,
	 300993160, 1765740623,  438357036,   64650456, 1935125408, 1580266195,
	1634347599, 1372825220, 1618889826, 1640156223,  425697703, 1885010806,
	 617651665,  923323310, 2078252329, 1561764248, 1663639491, 1076965730,
	1582773684,  174737898,  729244234, 1369862069,  658178623,  817132520,
	1013284789, 1446258571, 1548642213,  577140726,  202288442, 1302550874,
	   5699694,  143694176, 1957130183, 1011681553,  896045799, 1588814079,
	 174307020, 2010405410, 1387048505,  188015792,  672940168, 1924982686,
	1436988104, 1023518611,  982656561,  469334233, 1596517097,  364399787,
	2039377366, 1076699698, 1417164222, 1759039756, 1140061520, 1634104237,
	 438437910,   57231296,  716467918,   36877713,  206526271,  765993995,
	2013631225, 1977195771,  260055940,  179739511,  322258584, 1267265520,
	 787402577, 2046224021,  620754217, 1563997662,  643098641,  355623087,
	2022695761, 1286791925,  860977712,  943516276, 1100071272, 1113174801,
	 653645145, 1660035253, 1245199973,  752358570, 1222551862, 1775430823,
	  86612216, 2062571833,  322802261, 1235127002, 1817000159, 1400529963,
	1916686064,  355444581,  764934655, 1112803231, 1521974213, 1015175466,
	1482152159, 1146712531, 1230387615,  490930367,  519816765,  463925423,
	 344985544, 1424643552,  880938040, 2135122316, 1756992366, 1926237424,
	 436148971,  656681218,  652432843, 1811661106,  819600806, 1214027004,
	 858146988, 1382533297, 1021218996,   22088975,  998028820,   41559673,
	1792125582, 1089731404, 1219168775, 1276100632,  283839947,  564350328,
	1218090329,  924017223,  539409057, 1619620887, 1398513793, 1054571004,
	 895299788,  316520048,   58914203,  577335965,  874424904,  698714656,
	 591662930, 1071437952,   32201227, 1661530915,  379351956, 1905483518,
	 193218503, 1996955278, 1271856609,  267890848, 1128126656, 1732468852,
	1156885260,  496459157,  935069431,  606130843,  828712842, 2140229490,
	 724670039, 1373305728, 1414778007, 1658679940, 1889912627,  167277719,
	1462531801, 1401659402, 1929713629, 1738080194, 1705888413, 1201691419,
	1090717985,   88981489,  209446514,   46869354,  789334152, 1582208828,
	 964368475, 1539039116,   68376751,  122421185
};

/*
 * Convert a polynomial (signed, 16-bit) modulo p, then apply the NTT on it.
 * The source polynomial should either not overlap with the destination,
 * or be located in exactly the upper half of the destination array.
 *
 * Assumption: logn >= 3
 */
static inline void
mp_poly_to_NTT(unsigned logn, uint32_t *d, const int16_t *a,
	uint32_t p, uint32_t p0i, const uint32_t *gm)
{
	size_t n = (size_t)1 << logn;
	for (size_t u = 0; u < n; u ++) {
		uint32_t x = a[u];
		d[u] = x + (p & tbmask(x));
	}
	mp_NTT(logn, d, gm, p, p0i);
}

/*
 * Similar to mp_poly_to_NTT(), but for an auto-adjoint polynomial.
 * Only the first n/2 elements are written in d[].
 * The source polynomial should either not overlap with the destination,
 * or be located in exactly the upper half of the destination array.
 *
 * Assumption: logn >= 3
 */
static inline void
mp_poly_to_NTT_autoadj(unsigned logn, uint32_t *d, const int16_t *a,
	uint32_t p, uint32_t p0i, const uint32_t *gm)
{
	size_t hn = (size_t)1 << (logn - 1);
	for (size_t u = 0; u < hn; u ++) {
		uint32_t x = a[u];
		d[u] = x + (p & tbmask(x));
	}
	mp_NTT_autoadj(logn, d, gm, p, p0i);
}

/* ==================================================================== */
/*
 * Fixed-point FFT.
 * We use a fixed-mobile point representation, in which values are
 * represented over 32 bits (signed), and the position of the cutoff
 * between integral and fractional bits varies along the FFT computation
 * (but independently of the actual values).
 */

/*
 * For k in range(0, 1024):
 *    FX32_GM[2*k + 0] = round((2^31)*Re(zeta^rev(k)))
 *    FX32_GM[2*k + 1] = round((2^31)*Im(zeta^rev(k)))
 * with zeta = exp(2*i*pi/2048) (primitive 2048-th root of 1), and
 * rev() is the bit-reversal function over 10 bits.
 * Values for k = 0 and 1 are not used in practice. For all other values,
 * elements strictly fit in a signed 32-bit representation.
 */
static const int32_t FX32_GM[] = {
  -2147483648,           0,           0, -2147483648,  1518500250,  1518500250,
  -1518500250,  1518500250,  1984016189,   821806413,  -821806413,  1984016189,
    821806413,  1984016189, -1984016189,   821806413,  2106220352,   418953276,
   -418953276,  2106220352,  1193077991,  1785567396, -1785567396,  1193077991,
   1785567396,  1193077991, -1193077991,  1785567396,   418953276,  2106220352,
  -2106220352,   418953276,  2137142927,   210490206,  -210490206,  2137142927,
   1362349204,  1660027308, -1660027308,  1362349204,  1893911494,  1012316784,
  -1012316784,  1893911494,   623381598,  2055013723, -2055013723,   623381598,
   2055013723,   623381598,  -623381598,  2055013723,  1012316784,  1893911494,
  -1893911494,  1012316784,  1660027308,  1362349204, -1362349204,  1660027308,
    210490206,  2137142927, -2137142927,   210490206,  2144896910,   105372028,
   -105372028,  2144896910,  1442161874,  1591180426, -1591180426,  1442161874,
   1941302225,   918167572,  -918167572,  1941302225,   723465451,  2021950484,
  -2021950484,   723465451,  2083126254,   521795963,  -521795963,  2083126254,
   1104027237,  1841958164, -1841958164,  1104027237,  1724875040,  1279254516,
  -1279254516,  1724875040,   315101295,  2124240380, -2124240380,   315101295,
   2124240380,   315101295,  -315101295,  2124240380,  1279254516,  1724875040,
  -1724875040,  1279254516,  1841958164,  1104027237, -1104027237,  1841958164,
    521795963,  2083126254, -2083126254,   521795963,  2021950484,   723465451,
   -723465451,  2021950484,   918167572,  1941302225, -1941302225,   918167572,
   1591180426,  1442161874, -1442161874,  1591180426,   105372028,  2144896910,
  -2144896910,   105372028,  2146836866,    52701887,   -52701887,  2146836866,
   1480777044,  1555308768, -1555308768,  1480777044,  1963250501,   870249095,
   -870249095,  1963250501,   772868706,  2003586779, -2003586779,   772868706,
   2095304370,   470516330,  -470516330,  2095304370,  1148898640,  1814309216,
  -1814309216,  1148898640,  1755750017,  1236538675, -1236538675,  1755750017,
    367137861,  2115867626, -2115867626,   367137861,  2131333572,   262874923,
   -262874923,  2131333572,  1321199781,  1692961062, -1692961062,  1321199781,
   1868497586,  1058490808, -1058490808,  1868497586,   572761285,  2069693342,
  -2069693342,   572761285,  2039096241,   673626408,  -673626408,  2039096241,
    965532978,  1918184581, -1918184581,   965532978,  1626093616,  1402678000,
  -1402678000,  1626093616,   157978697,  2141664948, -2141664948,   157978697,
   2141664948,   157978697,  -157978697,  2141664948,  1402678000,  1626093616,
  -1626093616,  1402678000,  1918184581,   965532978,  -965532978,  1918184581,
    673626408,  2039096241, -2039096241,   673626408,  2069693342,   572761285,
   -572761285,  2069693342,  1058490808,  1868497586, -1868497586,  1058490808,
   1692961062,  1321199781, -1321199781,  1692961062,   262874923,  2131333572,
  -2131333572,   262874923,  2115867626,   367137861,  -367137861,  2115867626,
   1236538675,  1755750017, -1755750017,  1236538675,  1814309216,  1148898640,
  -1148898640,  1814309216,   470516330,  2095304370, -2095304370,   470516330,
   2003586779,   772868706,  -772868706,  2003586779,   870249095,  1963250501,
  -1963250501,   870249095,  1555308768,  1480777044, -1480777044,  1555308768,
     52701887,  2146836866, -2146836866,    52701887,  2147321946,    26352928,
    -26352928,  2147321946,  1499751576,  1537020244, -1537020244,  1499751576,
   1973781967,   846091463,  -846091463,  1973781967,   797397602,  1993951625,
  -1993951625,   797397602,  2100920556,   444768294,  -444768294,  2100920556,
   1171076495,  1800073849, -1800073849,  1171076495,  1770792044,  1214899813,
  -1214899813,  1770792044,   393075166,  2111202959, -2111202959,   393075166,
   2134398966,   236700388,  -236700388,  2134398966,  1341875533,  1676620432,
  -1676620432,  1341875533,  1881346202,  1035481766, -1035481766,  1881346202,
    598116479,  2062508835, -2062508835,   598116479,  2047209133,   648552838,
   -648552838,  2047209133,   988999351,  1906191570, -1906191570,   988999351,
   1643184191,  1382617710, -1382617710,  1643184191,   184248325,  2139565043,
  -2139565043,   184248325,  2143442326,   131685278,  -131685278,  2143442326,
   1422527051,  1608758157, -1608758157,  1422527051,  1929888720,   941921200,
   -941921200,  1929888720,   698598533,  2030676269, -2030676269,   698598533,
   2076566160,   547319836,  -547319836,  2076566160,  1081340445,  1855367581,
  -1855367581,  1081340445,  1709046739,  1300325060, -1300325060,  1709046739,
    289009871,  2127947206, -2127947206,   289009871,  2120213651,   341145265,
   -341145265,  2120213651,  1257991320,  1740443581, -1740443581,  1257991320,
   1828271356,  1126547765, -1126547765,  1828271356,   496193509,  2089372638,
  -2089372638,   496193509,  2012920201,   748223418,  -748223418,  2012920201,
    894275671,  1952423377, -1952423377,   894275671,  1573363068,  1461579514,
  -1461579514,  1573363068,    79042909,  2146028480, -2146028480,    79042909,
   2146028480,    79042909,   -79042909,  2146028480,  1461579514,  1573363068,
  -1573363068,  1461579514,  1952423377,   894275671,  -894275671,  1952423377,
    748223418,  2012920201, -2012920201,   748223418,  2089372638,   496193509,
   -496193509,  2089372638,  1126547765,  1828271356, -1828271356,  1126547765,
   1740443581,  1257991320, -1257991320,  1740443581,   341145265,  2120213651,
  -2120213651,   341145265,  2127947206,   289009871,  -289009871,  2127947206,
   1300325060,  1709046739, -1709046739,  1300325060,  1855367581,  1081340445,
  -1081340445,  1855367581,   547319836,  2076566160, -2076566160,   547319836,
   2030676269,   698598533,  -698598533,  2030676269,   941921200,  1929888720,
  -1929888720,   941921200,  1608758157,  1422527051, -1422527051,  1608758157,
    131685278,  2143442326, -2143442326,   131685278,  2139565043,   184248325,
   -184248325,  2139565043,  1382617710,  1643184191, -1643184191,  1382617710,
   1906191570,   988999351,  -988999351,  1906191570,   648552838,  2047209133,
  -2047209133,   648552838,  2062508835,   598116479,  -598116479,  2062508835,
   1035481766,  1881346202, -1881346202,  1035481766,  1676620432,  1341875533,
  -1341875533,  1676620432,   236700388,  2134398966, -2134398966,   236700388,
   2111202959,   393075166,  -393075166,  2111202959,  1214899813,  1770792044,
  -1770792044,  1214899813,  1800073849,  1171076495, -1171076495,  1800073849,
    444768294,  2100920556, -2100920556,   444768294,  1993951625,   797397602,
   -797397602,  1993951625,   846091463,  1973781967, -1973781967,   846091463,
   1537020244,  1499751576, -1499751576,  1537020244,    26352928,  2147321946,
  -2147321946,    26352928,  2147443222,    13176712,   -13176712,  2147443222,
   1509154322,  1527789007, -1527789007,  1509154322,  1978936331,   833964638,
   -833964638,  1978936331,   809617249,  1989021350, -1989021350,   809617249,
   2103610054,   431868915,  -431868915,  2103610054,  1182099496,  1792854372,
  -1792854372,  1182099496,  1778213194,  1204011567, -1204011567,  1778213194,
    406021865,  2108751352, -2108751352,   406021865,  2135811153,   223599506,
   -223599506,  2135811153,  1352137822,  1668355276, -1668355276,  1352137822,
   1887664383,  1023918550, -1023918550,  1887664383,   610760536,  2058800036,
  -2058800036,   610760536,  2051150040,   635979190,  -635979190,  2051150040,
   1000676905,  1900087301, -1900087301,  1000676905,  1651636841,  1372509294,
  -1372509294,  1651636841,   197372981,  2138394240, -2138394240,   197372981,
   2144209982,   118530885,  -118530885,  2144209982,  1432371426,  1599999411,
  -1599999411,  1432371426,  1935631910,   930061894,  -930061894,  1935631910,
    711045377,  2026351522, -2026351522,   711045377,  2079885360,   534567963,
   -534567963,  2079885360,  1092704411,  1848697674, -1848697674,  1092704411,
   1716993211,  1289814068, -1289814068,  1716993211,   302061269,  2126133817,
  -2126133817,   302061269,  2122266967,   328129457,  -328129457,  2122266967,
   1268646800,  1732691928, -1732691928,  1268646800,  1835149306,  1115308496,
  -1115308496,  1835149306,   509004318,  2086288720, -2086288720,   509004318,
   2017473321,   735858287,  -735858287,  2017473321,   906238681,  1946899451,
  -1946899451,   906238681,  1582301533,  1451898025, -1451898025,  1582301533,
     92209205,  2145503083, -2145503083,    92209205,  2146473080,    65873638,
    -65873638,  2146473080,  1471205974,  1564365367, -1564365367,  1471205974,
   1957873796,   882278992,  -882278992,  1957873796,   760560380,  2008291295,
  -2008291295,   760560380,  2092377892,   483364019,  -483364019,  2092377892,
   1137744621,  1821324572, -1821324572,  1137744621,  1748129707,  1247288478,
  -1247288478,  1748129707,   354148230,  2118080511, -2118080511,   354148230,
   2129680480,   275947592,  -275947592,  2129680480,  1310787095,  1701035922,
  -1701035922,  1310787095,  1861967634,  1069935768, -1069935768,  1861967634,
    560051104,  2073168777, -2073168777,   560051104,  2034924562,   686125387,
   -686125387,  2034924562,   953745043,  1924072871, -1924072871,   953745043,
   1617456335,  1412629117, -1412629117,  1617456335,   144834714,  2142593971,
  -2142593971,   144834714,  2140655293,   171116733,  -171116733,  2140655293,
   1392674072,  1634669676, -1634669676,  1392674072,  1912224073,   977284562,
   -977284562,  1912224073,   661102068,  2043191150, -2043191150,   661102068,
   2066139983,   585449903,  -585449903,  2066139983,  1047005996,  1874957189,
  -1874957189,  1047005996,  1684822463,  1331562723, -1331562723,  1684822463,
    249792358,  2132906420, -2132906420,   249792358,  2113575080,   380113669,
   -380113669,  2113575080,  1225742318,  1763304224, -1763304224,  1225742318,
   1807225553,  1160009405, -1160009405,  1807225553,   457650927,  2098151960,
  -2098151960,   457650927,  1998806829,   785147934,  -785147934,  1998806829,
    858186435,  1968553292, -1968553292,   858186435,  1546193612,  1490292364,
  -1490292364,  1546193612,    39528151,  2147119825, -2147119825,    39528151,
   2147119825,    39528151,   -39528151,  2147119825,  1490292364,  1546193612,
  -1546193612,  1490292364,  1968553292,   858186435,  -858186435,  1968553292,
    785147934,  1998806829, -1998806829,   785147934,  2098151960,   457650927,
   -457650927,  2098151960,  1160009405,  1807225553, -1807225553,  1160009405,
   1763304224,  1225742318, -1225742318,  1763304224,   380113669,  2113575080,
  -2113575080,   380113669,  2132906420,   249792358,  -249792358,  2132906420,
   1331562723,  1684822463, -1684822463,  1331562723,  1874957189,  1047005996,
  -1047005996,  1874957189,   585449903,  2066139983, -2066139983,   585449903,
   2043191150,   661102068,  -661102068,  2043191150,   977284562,  1912224073,
  -1912224073,   977284562,  1634669676,  1392674072, -1392674072,  1634669676,
    171116733,  2140655293, -2140655293,   171116733,  2142593971,   144834714,
   -144834714,  2142593971,  1412629117,  1617456335, -1617456335,  1412629117,
   1924072871,   953745043,  -953745043,  1924072871,   686125387,  2034924562,
  -2034924562,   686125387,  2073168777,   560051104,  -560051104,  2073168777,
   1069935768,  1861967634, -1861967634,  1069935768,  1701035922,  1310787095,
  -1310787095,  1701035922,   275947592,  2129680480, -2129680480,   275947592,
   2118080511,   354148230,  -354148230,  2118080511,  1247288478,  1748129707,
  -1748129707,  1247288478,  1821324572,  1137744621, -1137744621,  1821324572,
    483364019,  2092377892, -2092377892,   483364019,  2008291295,   760560380,
   -760560380,  2008291295,   882278992,  1957873796, -1957873796,   882278992,
   1564365367,  1471205974, -1471205974,  1564365367,    65873638,  2146473080,
  -2146473080,    65873638,  2145503083,    92209205,   -92209205,  2145503083,
   1451898025,  1582301533, -1582301533,  1451898025,  1946899451,   906238681,
   -906238681,  1946899451,   735858287,  2017473321, -2017473321,   735858287,
   2086288720,   509004318,  -509004318,  2086288720,  1115308496,  1835149306,
  -1835149306,  1115308496,  1732691928,  1268646800, -1268646800,  1732691928,
    328129457,  2122266967, -2122266967,   328129457,  2126133817,   302061269,
   -302061269,  2126133817,  1289814068,  1716993211, -1716993211,  1289814068,
   1848697674,  1092704411, -1092704411,  1848697674,   534567963,  2079885360,
  -2079885360,   534567963,  2026351522,   711045377,  -711045377,  2026351522,
    930061894,  1935631910, -1935631910,   930061894,  1599999411,  1432371426,
  -1432371426,  1599999411,   118530885,  2144209982, -2144209982,   118530885,
   2138394240,   197372981,  -197372981,  2138394240,  1372509294,  1651636841,
  -1651636841,  1372509294,  1900087301,  1000676905, -1000676905,  1900087301,
    635979190,  2051150040, -2051150040,   635979190,  2058800036,   610760536,
   -610760536,  2058800036,  1023918550,  1887664383, -1887664383,  1023918550,
   1668355276,  1352137822, -1352137822,  1668355276,   223599506,  2135811153,
  -2135811153,   223599506,  2108751352,   406021865,  -406021865,  2108751352,
   1204011567,  1778213194, -1778213194,  1204011567,  1792854372,  1182099496,
  -1182099496,  1792854372,   431868915,  2103610054, -2103610054,   431868915,
   1989021350,   809617249,  -809617249,  1989021350,   833964638,  1978936331,
  -1978936331,   833964638,  1527789007,  1509154322, -1509154322,  1527789007,
     13176712,  2147443222, -2147443222,    13176712,  2147473542,     6588387,
     -6588387,  2147473542,  1513834411,  1523151797, -1523151797,  1513834411,
   1981485585,   827889422,  -827889422,  1981485585,   815715670,  1986528118,
  -1986528118,   815715670,  2104925109,   425413098,  -425413098,  2104925109,
   1187594332,  1789219305, -1789219305,  1187594332,  1781898681,  1198550419,
  -1198550419,  1781898681,   412489512,  2107495770, -2107495770,   412489512,
   2136487095,   217045878,  -217045878,  2136487095,  1357249901,  1664199124,
  -1664199124,  1357249901,  1890796837,  1018122458, -1018122458,  1890796837,
    617073971,  2056916560, -2056916560,   617073971,  2053091544,   629683357,
   -629683357,  2053091544,  1006501581,  1897008325, -1897008325,  1006501581,
   1655839867,  1367435685, -1367435685,  1655839867,   203932553,  2137778644,
  -2137778644,   203932553,  2144563539,   111951983,  -111951983,  2144563539,
   1437273414,  1595597428, -1595597428,  1437273414,  1938476190,   924119082,
   -924119082,  1938476190,   717258790,  2024160529, -2024160529,   717258790,
   2081515603,   528184449,  -528184449,  2081515603,  1098370993,  1845336604,
  -1845336604,  1098370993,  1720942225,  1284540337, -1284540337,  1720942225,
    308582734,  2125197100, -2125197100,   308582734,  2123263666,   321616889,
   -321616889,  2123263666,  1273956653,  1728791620, -1728791620,  1273956653,
   1838562388,  1109673089, -1109673089,  1838562388,   515402566,  2084717298,
  -2084717298,   515402566,  2019721407,   729665303,  -729665303,  2019721407,
    912207419,  1944109987, -1944109987,   912207419,  1586748447,  1447036760,
  -1447036760,  1586748447,    98791081,  2145210092, -2145210092,    98791081,
   2146665076,    59288042,   -59288042,  2146665076,  1475998456,  1559844408,
  -1559844408,  1475998456,  1960571375,   876268167,  -876268167,  1960571375,
    766718151,  2005948478, -2005948478,   766718151,  2093850985,   476942419,
   -476942419,  2093850985,  1143327011,  1817825449, -1817825449,  1143327011,
   1751948107,  1241919421, -1241919421,  1751948107,   360644742,  2116984031,
  -2116984031,   360644742,  2130517052,   269412525,  -269412525,  2130517052,
   1315999631,  1697006479, -1697006479,  1315999631,  1865241388,  1064218296,
  -1064218296,  1865241388,   566408860,  2071440808, -2071440808,   566408860,
   2037019988,   679879097,  -679879097,  2037019988,   959643527,  1921137767,
  -1921137767,   959643527,  1621782608,  1407660183, -1407660183,  1621782608,
    151407418,  2142139541, -2142139541,   151407418,  2141170197,   164548489,
   -164548489,  2141170197,  1397682613,  1630389319, -1630389319,  1397682613,
   1915213340,   971413342,  -971413342,  1915213340,   667367379,  2041153301,
  -2041153301,   667367379,  2067926394,   579108320,  -579108320,  2067926394,
   1052753357,  1871736196, -1871736196,  1052753357,  1688899711,  1326387494,
  -1326387494,  1688899711,   256334847,  2132130030, -2132130030,   256334847,
   2114731305,   373627523,  -373627523,  2114731305,  1231146291,  1759535401,
  -1759535401,  1231146291,  1810775906,  1154459456, -1154459456,  1810775906,
    464085813,  2096738032, -2096738032,   464085813,  2001206222,   779011986,
   -779011986,  2001206222,   864221832,  1965911148, -1965911148,   864221832,
   1550758488,  1485541696, -1485541696,  1550758488,    46115236,  2146988450,
  -2146988450,    46115236,  2147230991,    32940695,   -32940695,  2147230991,
   1495029006,  1541614183, -1541614183,  1495029006,  1971176906,   852142959,
   -852142959,  1971176906,   791276492,  1996388622, -1996388622,   791276492,
   2099546139,   451211734,  -451211734,  2099546139,  1165548435,  1803658189,
  -1803658189,  1165548435,  1767056450,  1220326809, -1220326809,  1767056450,
    386596237,  2112398960, -2112398960,   386596237,  2133662734,   243247518,
   -243247518,  2133662734,  1336725419,  1680729357, -1680729357,  1336725419,
   1878160535,  1041248781, -1041248781,  1878160535,   591785976,  2064334124,
  -2064334124,   591785976,  2045209767,   654830535,  -654830535,  2045209767,
    983146583,  1909216806, -1909216806,   983146583,  1638934646,  1387652422,
  -1387652422,  1638934646,   177683365,  2140120240, -2140120240,   177683365,
   2143028234,   138260647,  -138260647,  2143028234,  1417584755,  1613114838,
  -1613114838,  1417584755,  1926989864,   947837582,  -947837582,  1926989864,
    692365218,  2032809982, -2032809982,   692365218,  2074877233,   553688076,
   -553688076,  2074877233,  1075643169,  1858676355, -1858676355,  1075643169,
   1705049355,  1305562222, -1305562222,  1705049355,   282480061,  2128823862,
  -2128823862,   282480061,  2119157054,   347648383,  -347648383,  2119157054,
   1252645794,  1744294853, -1744294853,  1252645794,  1824806552,  1132151521,
  -1132151521,  1824806552,   489781069,  2090885105, -2090885105,   489781069,
   2010615210,   754395449,  -754395449,  2010615210,   888281512,  1955157788,
  -1955157788,   888281512,  1568871601,  1466399645, -1466399645,  1568871601,
     72458615,  2146260881, -2146260881,    72458615,  2145775880,    85626460,
    -85626460,  2145775880,  1456745625,  1577839726, -1577839726,  1456745625,
   1949670589,   900261413,  -900261413,  1949670589,   742044345,  2015206245,
  -2015206245,   742044345,  2087840505,   502601279,  -502601279,  2087840505,
   1120933406,  1831718951, -1831718951,  1120933406,  1736575927,  1263325005,
  -1263325005,  1736575927,   334638936,  2121250292, -2121250292,   334638936,
   2127050522,   295536961,  -295536961,  2127050522,  1295075659,  1713028037,
  -1713028037,  1295075659,  1852041343,  1087027544, -1087027544,  1852041343,
    540946445,  2078235540, -2078235540,   540946445,  2028523442,   704825272,
   -704825272,  2028523442,   935995952,  1932769411, -1932769411,   935995952,
   1604386335,  1427455956, -1427455956,  1604386335,   125108670,  2143836244,
  -2143836244,   125108670,  2138989708,   190811551,  -190811551,  2138989708,
   1377569986,  1647418269, -1647418269,  1377569986,  1903148392,   994842810,
   -994842810,  1903148392,   642269036,  2049189231, -2049189231,   642269036,
   2060664133,   604441352,  -604441352,  2060664133,  1029705004,  1884514161,
  -1884514161,  1029705004,  1672495725,  1347013017, -1347013017,  1672495725,
    230151030,  2135115107, -2135115107,   230151030,  2109987085,   399550396,
   -399550396,  2109987085,  1209461382,  1774510970, -1774510970,  1209461382,
   1796472565,  1176593533, -1176593533,  1796472565,   438320667,  2102275199,
  -2102275199,   438320667,  1991495860,   803511207,  -803511207,  1991495860,
    840032004,  1976368450, -1976368450,   840032004,  1532411837,  1504460029,
  -1504460029,  1532411837,    19764913,  2147392690, -2147392690,    19764913,
   2147392690,    19764913,   -19764913,  2147392690,  1504460029,  1532411837,
  -1532411837,  1504460029,  1976368450,   840032004,  -840032004,  1976368450,
    803511207,  1991495860, -1991495860,   803511207,  2102275199,   438320667,
   -438320667,  2102275199,  1176593533,  1796472565, -1796472565,  1176593533,
   1774510970,  1209461382, -1209461382,  1774510970,   399550396,  2109987085,
  -2109987085,   399550396,  2135115107,   230151030,  -230151030,  2135115107,
   1347013017,  1672495725, -1672495725,  1347013017,  1884514161,  1029705004,
  -1029705004,  1884514161,   604441352,  2060664133, -2060664133,   604441352,
   2049189231,   642269036,  -642269036,  2049189231,   994842810,  1903148392,
  -1903148392,   994842810,  1647418269,  1377569986, -1377569986,  1647418269,
    190811551,  2138989708, -2138989708,   190811551,  2143836244,   125108670,
   -125108670,  2143836244,  1427455956,  1604386335, -1604386335,  1427455956,
   1932769411,   935995952,  -935995952,  1932769411,   704825272,  2028523442,
  -2028523442,   704825272,  2078235540,   540946445,  -540946445,  2078235540,
   1087027544,  1852041343, -1852041343,  1087027544,  1713028037,  1295075659,
  -1295075659,  1713028037,   295536961,  2127050522, -2127050522,   295536961,
   2121250292,   334638936,  -334638936,  2121250292,  1263325005,  1736575927,
  -1736575927,  1263325005,  1831718951,  1120933406, -1120933406,  1831718951,
    502601279,  2087840505, -2087840505,   502601279,  2015206245,   742044345,
   -742044345,  2015206245,   900261413,  1949670589, -1949670589,   900261413,
   1577839726,  1456745625, -1456745625,  1577839726,    85626460,  2145775880,
  -2145775880,    85626460,  2146260881,    72458615,   -72458615,  2146260881,
   1466399645,  1568871601, -1568871601,  1466399645,  1955157788,   888281512,
   -888281512,  1955157788,   754395449,  2010615210, -2010615210,   754395449,
   2090885105,   489781069,  -489781069,  2090885105,  1132151521,  1824806552,
  -1824806552,  1132151521,  1744294853,  1252645794, -1252645794,  1744294853,
    347648383,  2119157054, -2119157054,   347648383,  2128823862,   282480061,
   -282480061,  2128823862,  1305562222,  1705049355, -1705049355,  1305562222,
   1858676355,  1075643169, -1075643169,  1858676355,   553688076,  2074877233,
  -2074877233,   553688076,  2032809982,   692365218,  -692365218,  2032809982,
    947837582,  1926989864, -1926989864,   947837582,  1613114838,  1417584755,
  -1417584755,  1613114838,   138260647,  2143028234, -2143028234,   138260647,
   2140120240,   177683365,  -177683365,  2140120240,  1387652422,  1638934646,
  -1638934646,  1387652422,  1909216806,   983146583,  -983146583,  1909216806,
    654830535,  2045209767, -2045209767,   654830535,  2064334124,   591785976,
   -591785976,  2064334124,  1041248781,  1878160535, -1878160535,  1041248781,
   1680729357,  1336725419, -1336725419,  1680729357,   243247518,  2133662734,
  -2133662734,   243247518,  2112398960,   386596237,  -386596237,  2112398960,
   1220326809,  1767056450, -1767056450,  1220326809,  1803658189,  1165548435,
  -1165548435,  1803658189,   451211734,  2099546139, -2099546139,   451211734,
   1996388622,   791276492,  -791276492,  1996388622,   852142959,  1971176906,
  -1971176906,   852142959,  1541614183,  1495029006, -1495029006,  1541614183,
     32940695,  2147230991, -2147230991,    32940695,  2146988450,    46115236,
    -46115236,  2146988450,  1485541696,  1550758488, -1550758488,  1485541696,
   1965911148,   864221832,  -864221832,  1965911148,   779011986,  2001206222,
  -2001206222,   779011986,  2096738032,   464085813,  -464085813,  2096738032,
   1154459456,  1810775906, -1810775906,  1154459456,  1759535401,  1231146291,
  -1231146291,  1759535401,   373627523,  2114731305, -2114731305,   373627523,
   2132130030,   256334847,  -256334847,  2132130030,  1326387494,  1688899711,
  -1688899711,  1326387494,  1871736196,  1052753357, -1052753357,  1871736196,
    579108320,  2067926394, -2067926394,   579108320,  2041153301,   667367379,
   -667367379,  2041153301,   971413342,  1915213340, -1915213340,   971413342,
   1630389319,  1397682613, -1397682613,  1630389319,   164548489,  2141170197,
  -2141170197,   164548489,  2142139541,   151407418,  -151407418,  2142139541,
   1407660183,  1621782608, -1621782608,  1407660183,  1921137767,   959643527,
   -959643527,  1921137767,   679879097,  2037019988, -2037019988,   679879097,
   2071440808,   566408860,  -566408860,  2071440808,  1064218296,  1865241388,
  -1865241388,  1064218296,  1697006479,  1315999631, -1315999631,  1697006479,
    269412525,  2130517052, -2130517052,   269412525,  2116984031,   360644742,
   -360644742,  2116984031,  1241919421,  1751948107, -1751948107,  1241919421,
   1817825449,  1143327011, -1143327011,  1817825449,   476942419,  2093850985,
  -2093850985,   476942419,  2005948478,   766718151,  -766718151,  2005948478,
    876268167,  1960571375, -1960571375,   876268167,  1559844408,  1475998456,
  -1475998456,  1559844408,    59288042,  2146665076, -2146665076,    59288042,
   2145210092,    98791081,   -98791081,  2145210092,  1447036760,  1586748447,
  -1586748447,  1447036760,  1944109987,   912207419,  -912207419,  1944109987,
    729665303,  2019721407, -2019721407,   729665303,  2084717298,   515402566,
   -515402566,  2084717298,  1109673089,  1838562388, -1838562388,  1109673089,
   1728791620,  1273956653, -1273956653,  1728791620,   321616889,  2123263666,
  -2123263666,   321616889,  2125197100,   308582734,  -308582734,  2125197100,
   1284540337,  1720942225, -1720942225,  1284540337,  1845336604,  1098370993,
  -1098370993,  1845336604,   528184449,  2081515603, -2081515603,   528184449,
   2024160529,   717258790,  -717258790,  2024160529,   924119082,  1938476190,
  -1938476190,   924119082,  1595597428,  1437273414, -1437273414,  1595597428,
    111951983,  2144563539, -2144563539,   111951983,  2137778644,   203932553,
   -203932553,  2137778644,  1367435685,  1655839867, -1655839867,  1367435685,
   1897008325,  1006501581, -1006501581,  1897008325,   629683357,  2053091544,
  -2053091544,   629683357,  2056916560,   617073971,  -617073971,  2056916560,
   1018122458,  1890796837, -1890796837,  1018122458,  1664199124,  1357249901,
  -1357249901,  1664199124,   217045878,  2136487095, -2136487095,   217045878,
   2107495770,   412489512,  -412489512,  2107495770,  1198550419,  1781898681,
  -1781898681,  1198550419,  1789219305,  1187594332, -1187594332,  1789219305,
    425413098,  2104925109, -2104925109,   425413098,  1986528118,   815715670,
   -815715670,  1986528118,   827889422,  1981485585, -1981485585,   827889422,
   1523151797,  1513834411, -1513834411,  1523151797,     6588387,  2147473542,
  -2147473542,     6588387
};

static inline uint32_t
fx32_of(int32_t a, unsigned sh)
{
	return *(uint32_t *)&a << sh;
}

static inline int32_t
fx32_rint(uint32_t a, unsigned sh)
{
	a += (uint32_t)1 << (sh - 1);
	return *(int32_t *)&a >> sh;
}

/*
 * FFT algorithm in bit-reveral order formally works as follows:
 *
 *   t = n
 *   for m = 1; m < n; m *= 2:
 *       ht = t/2
 *       for i1 = 0; i1 < m; i1 ++:
 *           j1 = i1 * t
 *           s = GM[m + i1]
 *           for j = j1; j < (j1 + ht); j ++:
 *               x = f[j]
 *               y = s * f[j + ht]
 *               f[j] = x + y
 *               f[j + ht] = x - y
 *       t = ht
 *
 * GM[k] contains (exp(i*pi/n))^rev(k), with rev() = bit-reversal function
 * over log(n) bits. All values are complex numbers.
 *
 * We work over real polynomials; on input (non-FFT), the imaginary parts
 * are zero (and implicit). Moreover, GM[1] = exp(i*(pi/n)*(n/2)) = i.
 * Thus, the first outer iteration (for m = 1) really is:
 *    for j = 0; j < n/2; j ++:
 *       x = f[j]
 *       y = i * f[j + n/2]
 *       f[j] = x + y
 *       f[j + ht] = x - y
 * For a real polynomial f, the FFT representation f' is such that
 * f'[i + n/2] = conj(f'[i]); thus, we can omit half of the coefficients.
 * We have n/2 FFT coefficients to store, each being a complex number;
 * we separate the real and imaginary parts, so that the real part of f[i]
 * is stored at array index i, while the imaginary part is at index i + n/2.
 * With these conventions, the first FFT iteration (m = 1) becomes a complete
 * no-op, we can simply skip it altogether.
 *
 * Auto-adjoint polynomials
 * ------------------------
 *
 * An auto-adjoint polynomial is f such that f = adj(f). This implies that:
 *    for all i > 0, f[i] = -f[n - i]
 *    FFT(f) contains only real coefficients
 * For such polynomials, we can use only n/2 words in RAM (encoding the real
 * parts of the first n/2 FFT coefficients). Intermediate values, however,
 * are not real, so the FFT itself must still use a full-size array.
 *
 * Scaling
 * -------
 *
 * To get better precision, values are upscaled (left-shifted) so that we
 * get as many fractional bits as possible, without risking an overflow.
 * At each iteration of the algorithm, the scaling is lowered (i.e. values
 * are halved) to guarantee against overflows, so that the result is
 * downscaled by logn-1 (on top of the upscaling). We take that upscaling
 * into account when performing divisions.
 */

/*
 * Apply the FFT on a given real polynomial.
 *
 * Assumption: logn >= 3
 */
static void
fx32_FFT(unsigned logn, uint32_t *a)
{
	size_t hn = (size_t)1 << (logn - 1);
	size_t t = hn;
	for (unsigned lm = 1; lm < logn; lm ++) {
		size_t m = (size_t)1 << lm;
		size_t ht = t >> 1;
		size_t j0 = 0;
		size_t hm = m >> 1;
		for (size_t i = 0; i < hm; i ++) {
			uint32_t s_re = (uint32_t)FX32_GM[((i + m) << 1) + 0];
			uint32_t s_im = (uint32_t)FX32_GM[((i + m) << 1) + 1];
			for (size_t j = j0; j < j0 + ht; j ++) {
				uint32_t x1_re = a[j];
				uint32_t x1_im = a[j + hn];
				uint32_t x2_re = a[j + ht];
				uint32_t x2_im = a[j + ht + hn];

#define M(c, d)   ((uint64_t)((int64_t)*(int32_t *)&(c) \
                   * (int64_t)*(int32_t *)&(d)))
#define SSX(c)    ((uint64_t)*(int32_t *)&(c) << 31)
				/*
				 * t <- s*x2
				 * (x1, x2) <- ((x1 + t)/2, (x2 - t)/2)
				 */
				uint64_t t_re = M(x2_re, s_re) - M(x2_im, s_im);
				uint64_t t_im = M(x2_re, s_im) + M(x2_im, s_re);
				a[j]           = (SSX(x1_re) + t_re) >> 32;
				a[j + hn]      = (SSX(x1_im) + t_im) >> 32;
				a[j + ht]      = (SSX(x1_re) - t_re) >> 32;
				a[j + ht + hn] = (SSX(x1_im) - t_im) >> 32;
#undef M
#undef SSX
			}
			j0 += t;
		}
		t = ht;
	}
}

/*
 * Apply the inverse FFT on a given real polynomial.
 *
 * Assumption: logn >= 3
 */
static void
fx32_iFFT(unsigned logn, uint32_t *a)
{
	size_t hn = (size_t)1 << (logn - 1);
	size_t ht = 1;
	for (unsigned lm = logn - 1; lm > 0; lm --) {
		size_t m = (size_t)1 << lm;
		size_t t = ht << 1;
		size_t j0 = 0;
		size_t hm = m >> 1;
		for (size_t i = 0; i < hm; i ++) {
			uint32_t s_re = (uint32_t)FX32_GM[((i + m) << 1) + 0];
			uint32_t s_im = -(uint32_t)FX32_GM[((i + m) << 1) + 1];
			for (size_t j = j0; j < j0 + ht; j ++) {
				uint32_t x1_re = a[j];
				uint32_t x1_im = a[j + hn];
				uint32_t x2_re = a[j + ht];
				uint32_t x2_im = a[j + ht + hn];

#define M(c, d)   ((uint64_t)((int64_t)*(int32_t *)&(c) \
                   * (int64_t)*(int32_t *)&(d)))
#define H(c)       ((uint32_t)(*(int32_t *)&(c) >> 1))
				/*
				 * t1 <- x1 + x2
				 * t2 <- s*(x1 - x2)
				 * (x1, x2) <- (t1/2, t2/2)
				 */
				uint32_t t1_re = x1_re + x2_re;
				uint32_t t1_im = x1_im + x2_im;
				uint32_t t2_re = x1_re - x2_re;
				uint32_t t2_im = x1_im - x2_im;

				a[j]           = H(t1_re);
				a[j + hn]      = H(t1_im);
				a[j + ht]      = (M(t2_re, s_re)
				                 - M(t2_im, s_im)) >> 32;
				a[j + ht + hn] = (M(t2_re, s_im)
				                 + M(t2_im, s_re)) >> 32;
#undef M
#undef H
			}
			j0 += t;
		}
		ht = t;
	}
}

/* ==================================================================== */

/*
 * Limits for q00, q01 and s1 (maximum bit size of the absolute value of
 * a coefficient, excluding q00[0] and q11[0]).
 */
static const int8_t bits_lim00[11] = {
	0, 0, 0, 0, 0, 0, 0, 0,  9,  9, 10
};
static const int8_t bits_lim01[11] = {
	0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 14
};
static const int8_t bits_lims0[11] = {
	0, 0, 0, 0, 0, 0, 0, 0, 12, 13, 14
};
static const int8_t bits_lims1[11] = {
	0, 0, 0, 0, 0, 0, 0, 0,  9,  9, 10
};

/*
 * Decode n = 2^logn values into d from a provided buffer, using
 * Golomb-Rice coding. The sign, fixed part ('low' bits) and
 * variable part (high bits) are segregated.
 *
 * Values are verified to be such that -2^lim_bits <= d[i] < +2^lim_bits.
 * The number of ignored bits in the last byte is written into *num_ignored
 * (unless num_ignored == NULL). Total size (in bytes) is returned.
 *
 * ASSUMPTION: lim_bits <= low + 4
 */
static size_t
decode_gr(unsigned logn, int16_t *d, const uint8_t *buf, size_t buf_len,
	int low, int lim_bits, int *num_ignored)
{
	size_t n = (size_t)1 << logn;
	if (buf_len < ((uint32_t)(low + 1) << (logn - 3))) {
		return 0;
	}
	size_t voff = (size_t)(low + 1) << (logn - 3);

	/*
	 * Precomputed table for the number of trailing zeros in an
	 * 8-bit value.
	 */
	static const uint8_t ntz[256] = {
		8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
	};

	/*
	 * Variable part.
	 */
	uint32_t acc = 0;
	int acc_off = 0;
	int lim_hi = 1 << (lim_bits - low);
	for (size_t u = 0; u < n; u ++) {
		while (acc == 0) {
			if (acc_off >= lim_hi) {
				return 0;
			}
			if (voff >= buf_len) {
				return 0;
			}
			acc |= (uint32_t)buf[voff ++] << acc_off;
			acc_off += 8;
		}
		int k = ntz[acc & 0xFF];
		if (k == 8) {
			k += ntz[(acc >> 8) & 0xFF];
			if (k >= lim_hi) {
				return 0;
			}
		}
		d[u] = k << low;
		acc >>= k + 1;
		acc_off -= k + 1;
	}
	if (num_ignored != NULL) {
		*num_ignored = acc_off;
	}

	/*
	 * Sign bits and fixed-width parts.
	 */
	size_t loff = (size_t)1 << (logn - 3);
	uint32_t lmask = ((uint32_t)1 << low) - 1;
	if (low <= 8) {
		for (size_t u = 0; u < n; u += 8) {
			uint32_t sbb = buf[u >> 3];
			uint64_t lpp = 0;
			for (int j = 0; j < (low << 3); j += 8) {
				lpp |= (uint64_t)buf[loff ++] << j;
			}
			for (int i = 0, j = 0; i < 8; i ++, j += low) {
				uint32_t lp = (uint32_t)(lpp >> j) & lmask;
				uint32_t sm = -((sbb >> i) & 1);
				((uint16_t *)d)[u + (size_t)i] ^= sm ^ lp;
			}
		}
	} else {
		for (size_t u = 0; u < n; u += 8) {
			uint32_t sbb = buf[u >> 3];
			uint32_t lpp0 = dec32le(buf + loff);
			loff += 4;
			uint64_t lpp1 = 0;
			for (int j = 4, k = 0; j < low; j ++, k += 8) {
				lpp1 |= (uint64_t)buf[loff ++] << k;
			}
			for (int i = 0, j = 0; i < 3; i ++, j += low) {
				uint32_t lp = (lpp0 >> j) & lmask;
				uint32_t sm = -((sbb >> i) & 1);
				((uint16_t *)d)[u + (size_t)i] ^= sm ^ lp;
			}
			lpp1 = (lpp1 << (32 - 3 * low))
				| (uint64_t)(lpp0 >> (3 * low));
			for (int i = 3, j = 0; i < 8; i ++, j += low) {
				uint32_t lp = (uint32_t)(lpp1 >> j) & lmask;
				uint32_t sm = -((sbb >> i) & 1);
				((uint16_t *)d)[u + (size_t)i] ^= sm ^ lp;
			}
		}
	}

	return voff;
}

#define decode_gr_5_9(logn, d, buf, buf_len, pni) \
	decode_gr(logn, d, buf, buf_len, 5, 9, pni)
#define decode_gr_6_10(logn, d, buf, buf_len, pni) \
	decode_gr(logn, d, buf, buf_len, 6, 10, pni)
#define decode_gr_8_11(logn, d, buf, buf_len, pni) \
	decode_gr(logn, d, buf, buf_len, 8, 11, pni)
#define decode_gr_9_12(logn, d, buf, buf_len, pni) \
	decode_gr(logn, d, buf, buf_len, 9, 12, pni)
#define decode_gr_10_14(logn, d, buf, buf_len, pni) \
	decode_gr(logn, d, buf, buf_len, 10, 14, pni)

/*
 * Decode q00 from the source public key. The provided 'buf' must point to
 * the first byte of the encoding of q00. Output values are written into d[].
 *
 * Note: q00 is auto-adjoint so only 2^(logn-1) values are decoded and
 * returned.
 *
 * Returned value is the encoded length of q00, in bytes.
 */
static size_t
decode_q00(unsigned logn, int16_t *q00, const uint8_t *buf, size_t buf_len)
{
	int lim_len;
	int ni;
	size_t len;
	switch (logn) {
	case 8:
		lim_len = 9;
		len = decode_gr_5_9(logn - 1, q00, buf, buf_len, &ni);
		break;
	case 9:
		lim_len = 9;
		len = decode_gr_5_9(logn - 1, q00, buf, buf_len, &ni);
		break;
	default:
		lim_len = 10;
		len = decode_gr_6_10(logn - 1, q00, buf, buf_len, &ni);
		break;
	}
	if (len == 0) {
		return 0;
	}

	/*
	 * q00[0] has a special encoding: decoded value was scaled down,
	 * and must be scaled up again.
	 */
	int eb00_len = 16 - lim_len;
	int32_t eb00;
	unsigned last;
	if (eb00_len <= ni) {
		last = (unsigned)buf[len - 1] >> (8 - ni);
		eb00 = last;
		last >>= eb00_len;
	} else {
		if (len >= buf_len) {
			return 0;
		}
		eb00 = (unsigned)buf[len - 1] >> (8 - ni);
		last = buf[len ++];
		eb00 |= last << ni;
		last >>= eb00_len - ni;
	}
	if (last != 0) {
		return 0;
	}
	q00[0] = (q00[0] << eb00_len) | eb00;
	return len;
}

/*
 * Like decode_q00(), but for q01. n values are produced. This function
 * expects to receive the current buf / buf_len values. It reports an
 * error if the last unused bits of the last byte are not zero.
 *
 * Returned value: actual encoded length (in bytes), or 0 on error.
 */
static size_t
decode_q01(unsigned logn, int16_t *q01, const uint8_t *buf, size_t buf_len)
{
	int ni;
	size_t len;
	switch (logn) {
	case 8:
		len = decode_gr_8_11(logn, q01, buf, buf_len, &ni);
		break;
	case 9:
		len = decode_gr_9_12(logn, q01, buf, buf_len, &ni);
		break;
	default:
		len = decode_gr_10_14(logn, q01, buf, buf_len, &ni);
		break;
	}
	if (len > 0 && ((unsigned)buf[len - 1] >> (8 - ni)) != 0) {
		return 0;
	}
	return len;
}

/*
 * Check padding. Return value is 1 if the padding is correct, 0 otherwise.
 */
static int
check_padding(const uint8_t *buf, size_t len)
{
	while (len -- > 0) {
		if (*buf ++ != 0) {
			return 0;
		}
	}
	return 1;
}

/*
 * Decode s1. Returned value is 0 on error, or the actual encoded length
 * of s1 otherwise. This function checks that the unused bits in the last
 * used byte are zero.
 */
static size_t
decode_s1(unsigned logn, int16_t *s1, const uint8_t *buf, size_t buf_len)
{
	int ni;
	size_t len;
	switch (logn) {
	case 8:
	case 9:
		len = decode_gr_5_9(logn, s1, buf, buf_len, &ni);
		break;
	default:
		len = decode_gr_6_10(logn, s1, buf, buf_len, &ni);
		break;
	}
	if (len > 0 && ((unsigned)buf[len - 1] >> (8 - ni)) != 0) {
		return 0;
	}
	return len;
}

/*
 * Decode the signature (salt and s1). This function returns an error if
 * there is trailing garbage (non-zero bits in the padding, including the
 * unused bits in the last used byte).
 *
 * salt can be NULL, in which case the salt is skipped (salt_len must still
 * contain the correct salt length).
 *
 * Returned value: 1 on success, 0 on error.
 */
static int
decode_sig_inner(unsigned logn, uint8_t *salt, size_t salt_len, int16_t *s1,
	const uint8_t *buf, size_t buf_len)
{
	if (buf_len < salt_len) {
		return 0;
	}
	if (salt != NULL) {
		memcpy(salt, buf, salt_len);
	}
	buf += salt_len;
	buf_len -= salt_len;
	size_t s1_len = decode_s1(logn, s1, buf, buf_len);
	if (s1_len == 0) {
		return 0;
	}
	return check_padding(buf + s1_len, buf_len - s1_len);
}

/* see hawk.h */
int
Zh(decode_public_key)(unsigned logn, int16_t *q00_q01_hpk,
	const void *restrict pub, size_t pub_len)
{
	if (logn < 8 || logn > 10) {
		return 0;
	}
	if (pub_len != HAWK_PUBKEY_SIZE(logn)) {
		return 0;
	}
	int16_t *q00 = q00_q01_hpk;
	int16_t *q01 = q00 + ((size_t)1 << (logn - 1));
	void *hpk = q01 + ((size_t)1 << logn);
	size_t hpub_len = (size_t)1 << (logn - 4);
	const uint8_t *buf = (const uint8_t *)pub;
	size_t buf_len = pub_len;

	/* Decode q00 */
	size_t len00 = decode_q00(logn, q00, buf, buf_len);
	if (len00 == 0) {
		return 0;
	}
	buf += len00;
	buf_len -= len00;

	/* Decode q01 */
	size_t len01 = decode_q01(logn, q01, buf, buf_len);
	if (len01 == 0) {
		return 0;
	}

	/* Check that the padding is correct */
	if (!check_padding(buf + len01, buf_len - len01)) {
		return 0;
	}

	/* Recompute SHAKE256(pub) with the appropriate length */
	shake_context sc;
	shake_init(&sc, 256);
	shake_inject(&sc, pub, pub_len);
	shake_flip(&sc);
	shake_extract(&sc, hpk, hpub_len);

	return 1;
}

/* see hawk.h */
int
Zh(decode_signature)(unsigned logn, int16_t *s1_and_salt,
	const void *restrict sig, size_t sig_len)
{
	size_t salt_len;
	switch (logn) {
	case 8:   salt_len = 14; break;
	case 9:   salt_len = 24; break;
	case 10:  salt_len = 40; break;
	default:
		return 0;
	}
	if (sig_len != HAWK_SIG_SIZE(logn)) {
		return 0;
	}
	int16_t *s1 = s1_and_salt;
	uint8_t *salt = (uint8_t *)(s1 + ((size_t)1 << logn));
	return decode_sig_inner(logn, salt, salt_len, s1, sig, sig_len);
}

/*
 * Decode s1 and recompute t1, given h1.
 */
static inline void
make_t1(unsigned logn, int16_t *d, const uint8_t *h1)
{
	size_t n = (size_t)1 << logn;
	for (size_t u = 0; u < n; u += 8) {
		uint32_t h1b = h1[u >> 3];
		for (size_t v = 0; v < 8; v ++, h1b >>= 1) {
			uint32_t x = d[u + v];
			x = (h1b & 1) - (x << 1);
			d[u + v] = (int16_t)*(int32_t *)&x;
		}
	}
}

/*
 * Inner verification function; non-static so that it may be invoked
 * from the test code. If ss != NULL, then it should point to a buffer
 * of size 4*n + 8 bytes, which receives, in that order: s0, s1, tnorm1
 * and tnorm2 (s0 and s1 are int16_t[n] each, tnorm1 and tnorm2 are
 * uint32_t).
 */
int
Zh(verify_inner)(unsigned logn,
	const void *restrict sig, size_t sig_len,
	const shake_context *restrict sc_data,
	const void *restrict pub, size_t pub_len,
	void *restrict tmp, size_t tmp_len, void *restrict ss)
{
	/*
	 * Check degree and align temporary buffer.
	 */
	if (logn < 8 || logn > 10) {
		return 0;
	}
	if (tmp_len < 7) {
		return 0;
	}
	uintptr_t utmp1 = (uintptr_t)tmp;
	uintptr_t utmp2 = (utmp1 + 7) & ~(uintptr_t)7;
	tmp_len -= (size_t)(utmp2 - utmp1);
	uint32_t *tt32 = (void *)utmp2;
	if (tmp_len < ((size_t)10 << logn)) {
		return 0;
	}

	size_t salt_len;
	uint32_t max_tnorm;  /* floor((sigma_ver^2)*8*n */
	switch (logn) {
	case 8:
		salt_len = 14;
		max_tnorm = 2223;
		break;
	case 9:
		salt_len = 24;
		max_tnorm = 8317;
		break;
	case 10:
		salt_len = 40;
		max_tnorm = 20218;
		break;
	default:
		return 0;
	}

	size_t n = (size_t)1 << logn;
	size_t hn = n >> 1;

	/*
	 * Decode the signature, resulting into the salt and s1 polynomial.
	 */
	int16_t *s1;
	uint8_t *salt;
	const uint8_t *s1buf = NULL;
	size_t s1buf_len = 0;
	if (sig_len == (size_t)-1) {
		s1 = (int16_t *)sig;
		salt = (uint8_t *)(s1 + n);
	} else {
		s1 = (int16_t *)tt32;
		salt = (uint8_t *)(s1 + n);
		if (sig_len != HAWK_SIG_SIZE(logn)) {
			return 0;
		}
		if (!decode_sig_inner(logn, salt, salt_len, s1, sig, sig_len)) {
			return 0;
		}
		s1buf = (const uint8_t *)sig + salt_len;
		s1buf_len = sig_len - salt_len;
	}

	/* Copy s1 to the test buffer (if present). */
	if (ss != NULL) {
		memcpy((uint8_t *)ss + (2 * n), s1, 2 * n);
	}

#if HAWK_DEBUG
	printf("#### Verify (n=%u):\n", 1u << logn);
	print_blob("salt", salt, salt_len);
	print_i16(logn, "s1", s1);
#endif

	/*
	 * Compute:
	 *    hm = SHAKE256(message || H(pub))
	 *    h = SHAKE256(hm || salt)
	 * H(pub) is SHAKE256 over the public key, with output length
	 * 16, 32 or 64 bytes (for n = 256, 512 or 1024).
	 * hm has length 64 bytes (always).
	 *
	 * We keep h into a stack buffer (at most 256 bytes, this is small
	 * enough not to warrant storing in tmp).
	 */
	uint8_t h[256];
	const void *hpub;
	size_t hpub_len = (size_t)1 << (logn - 4);
	shake_context scd;
	if (pub_len == (size_t)-1) {
		hpub = (const uint8_t *)pub + (3 * n);
	} else {
		shake_init(&scd, 256);
		shake_inject(&scd, pub, pub_len);
		shake_flip(&scd);
		shake_extract(&scd, h, hpub_len);
		hpub = h;
	}
	scd = *sc_data;
	shake_inject(&scd, hpub, hpub_len);
	shake_flip(&scd);
	shake_extract(&scd, h, 64);
#if HAWK_DEBUG
	printf("# hm = SHAKE256(message || hpub) (64 bytes)\n");
	print_blob("hm", h, 64);
#endif
	shake_init(&scd, 256);
	shake_inject(&scd, h, 64);
	shake_inject(&scd, salt, salt_len);
	shake_flip(&scd);
	shake_extract(&scd, h, n >> 2);

#if HAWK_DEBUG
	printf("# h = SHAKE256(hm || salt) (2*n bits)\n");
	print_u1(logn, "h0", h);
	print_u1(logn, "h1", h + (n >> 3));
#endif

	/*
	 * Target memory layout, with polynomials in fx32 format:
	 *   fq00    2*n bytes
	 *   fq01    4*n bytes
	 *   ft1     4*n bytes
	 * Polynomials are scaled by some bits; shift counts are such that
	 * we get maximum precision but no overflow.
	 */
	uint32_t *fq00 = tt32;
	uint32_t *fq01 = fq00 + hn;
	uint32_t *ft1 = fq01 + n;
	int sh_q00 = 29 - bits_lim00[logn];
	int sh_q01 = 29 - bits_lim01[logn];
	int sh_t1 = 29 - (1 + bits_lims1[logn]);

	/*
	 * Compute t1 = h1 - 2*s1 and convert to fx32 format + FFT.
	 * We also check that sym-break(h1 - 2*s1) is true.
	 */
	uint32_t csb = 0xFFFFFFFF;
	for (size_t u = 0; u < n; u += 8) {
		uint32_t hb = h[(n >> 3) + (u >> 3)];
		for (size_t v = 0; v < 8; v ++, hb >>= 1) {
			uint32_t w = (uint32_t)s1[u + v];
			w = (hb & 1) - (w << 1);
			ft1[u + v] = fx32_of(*(int32_t *)&w, sh_t1);
			if ((csb & w) >> 31) {
				/* First non-zero value is negative. */
				return 0;
			}
			csb &= ~tbmask(-w);
		}
	}
	if (csb) {
		/* t1 is entirely 0, this is not valid */
		return 0;
	}
	fx32_FFT(logn, ft1);

#if HAWK_DEBUG
	printf("# ft1 = FFT(h1 - 2*s1)\n");
	print_i32(logn, "ft1", (int32_t *)ft1);
#endif

	/*
	 * Decode the first public key polynomial (q00). We put it
	 * temporarily at offset 4*n (bytes) in the temporary array.
	 */
	int16_t *q00;
	uint8_t *q00buf = NULL;
	size_t q00buf_len = 0;
	if (pub_len == (size_t)-1) {
		q00 = (int16_t *)pub;
	} else {
		q00 = (int16_t *)fq01 + n;
		if (pub_len != HAWK_PUBKEY_SIZE(logn)) {
			return 0;
		}
		q00buf = (uint8_t *)pub;
		q00buf_len = decode_q00(logn, q00, q00buf, pub_len - 1);
		if (q00buf_len == 0) {
			return 0;
		}
	}

#if HAWK_DEBUG
	printf("# first half of q00 only\n");
	print_i16(logn - 1, "q00", q00);
#endif

	/*
	 * q00 = f*adj(f) + g*adj(g) (mod X^n+1)
	 * adj(f) = f_0 - \sum_{i=1}^{n-1} f_{n-i}*X^i
	 * Thus, q00[0] = f_0^2 + g_0^2 + \sum_{i=1}^{n-1} (f_i^2 + g_i^2)
	 * Therefore, it must be non-negative.
	 */
	if (q00[0] < 0) {
		return 0;
	}

	/*
	 * Convert q00 to fx32 and apply the FFT. Since q00 is auto-adjoint,
	 * we must complete it for the FFT; however, afterwards, we can
	 * ignore the last n/2 words (the imaginary parts of the FFT
	 * coefficients should all be zero).
	 *
	 * The constant term of q00 can be large, so we clear it first, to
	 * avoid overflow; it will become a corrective value later on.
	 */
	int32_t cstq00 = q00[0];
	fq00[0] = 0;
	fq00[hn] = 0;
	for (size_t u = 1; u < hn; u ++) {
		uint32_t z = fx32_of(q00[u], sh_q00);
		fq00[u] = z;
		fq00[n - u] = -z;
	}
	fx32_FFT(logn, fq00);

#if HAWK_DEBUG
	printf("# fq00 = FFT(q00') (q00' = q00 except that q00'[0] = 0)\n");
	print_i32(logn, "fq00", (int32_t *)fq00);
#endif

	/*
	 * Decode q01 and convert it to fx32 + FFT. The conversion to fx32
	 * is done in-place; to deal with the overlap, we ensure that q01
	 * is written into the second half of fq01.
	 */
	int16_t *q01;
	uint8_t *q01buf = NULL;
	size_t q01buf_len = 0;
	if (pub_len == (size_t)-1) {
		q01 = (int16_t *)pub + hn;
	} else {
		q01 = (int16_t *)(fq01 + hn);
		q01buf = q00buf + q00buf_len;
		q01buf_len = pub_len - q00buf_len;
		size_t len01 = decode_q01(logn, q01, q01buf, q01buf_len);
		if (len01 == 0) {
			return 0;
		}
		/* This is the first decoding of the public key; we must
		   check the padding. */
		if (!check_padding(q01buf + len01, q01buf_len - len01)) {
			return 0;
		}
	}
#if HAWK_DEBUG
	print_i16(logn, "q01", q01);
#endif

	for (size_t u = 0; u < n; u ++) {
		fq01[u] = fx32_of(q01[u], sh_q01);
	}
	fx32_FFT(logn, fq01);

#if HAWK_DEBUG
	printf("# fq01 = FFT(q01)\n");
	print_i32(logn, "fq01", (int32_t *)fq01);
#endif

	/*
	 * fq01 <- (q01*t1)/q00
	 */

	/*
	 * We inject back q00[0] here; in FFT representation, it must be
	 * added to all elements. Note the following:
	 *  - q00 = f*adj(f) + g*adj(g); in FFT representation, the
	 *    coefficients of f*adj(f) are non-negative real numbers,
	 *    so the same must hold for q00 (if the public key is valid).
	 *  - Our fixed-point representation was adjusted such that the
	 *    values in fq00[] are less than 2^29.
	 *  - q00[0] is a 16-bit integer (necessarily non-negative) and
	 *    is here shifted by at most 13 bits, which again yield an
	 *    integer lower than 2^28.
	 * Thus, in the loop below, all divisors should be positive integers
	 * less than 2^30; if they are not, then the public key is invalid
	 * and we should reject it.
	 *
	 * In each division, the dividend is the sum (or difference) of
	 * two products of elements of fq01[] and ft1[]; these elements are
	 * also bound by 2^29 (in absolute value), so the dividend cannot be
	 * greater than 2^58 (in absolute value). To enforce reproducible
	 * checks, we perform the following:
	 *
	 *   - Negative dividends are negated, so that we always divide a
	 *     positive value by the positive divisor; we can do that with
	 *     an unsigned division. The sign is applied afterwards to the
	 *     result.
	 *
	 *   - We explicitly check that the upper word of the dividend is
	 *     lower than the divisor; this guarantees that the quotient
	 *     fits in an (unsigned) 32-bit word.
	 *
	 * In particular, it is possible to use an unsigned 64-by-32
	 * division, such as the one-operand 'div' 32-bit opcode on x86
	 * (dividend is in edx:eax, quotient is returned in eax and
	 * remainder in edx); there will be no overflow, hence no CPU
	 * exception. This cannot be expressed in C, since C division
	 * operators (and the standard div(), ldiv() and lldiv()
	 * functions) always use the same type for the two operands, and
	 * the C compiler does not understand that thanks to our checks,
	 * our results will always fit. When using GCC or Clang on x86,
	 * we can use some inline assembly.
	 */
	uint32_t cstup = (uint32_t)cstq00 << (sh_q00 - (logn - 1));
	for (size_t u = 0; u < hn; u ++) {
#define M(c, d)   ((uint64_t)((int64_t)*(int32_t *)&(c) \
                   * (int64_t)*(int32_t *)&(d)))

		uint32_t q01_re = fq01[u];
		uint32_t q01_im = fq01[u + hn];
		uint32_t t1_re = ft1[u];
		uint32_t t1_im = ft1[u + hn];
		uint64_t x_re = M(q01_re, t1_re) - M(q01_im, t1_im);
		uint64_t x_im = M(q01_re, t1_im) + M(q01_im, t1_re);

		uint64_t sx_re = (uint64_t)(*(int64_t *)&x_re >> 63);
		uint64_t sx_im = (uint64_t)(*(int64_t *)&x_im >> 63);
		x_re = (x_re ^ sx_re) - sx_re;
		x_im = (x_im ^ sx_im) - sx_im;

		uint32_t x_re_hi = (uint32_t)(x_re >> 32);
		uint32_t x_re_lo = (uint32_t)x_re;
		uint32_t x_im_hi = (uint32_t)(x_im >> 32);
		uint32_t x_im_lo = (uint32_t)x_im;
		uint32_t w00 = cstup + fq00[u];
		if ((w00 - 1) >= 0x3FFFFFFF
			|| x_re_hi >= w00 || x_im_hi >= w00)
		{
			/* Division would overflow. This should never happen
			   with a valid signature. */
			return 0;
		}
		uint32_t y_re = (((uint64_t)x_re_hi << 32) | x_re_lo) / w00;
		uint32_t y_im = (((uint64_t)x_im_hi << 32) | x_im_lo) / w00;

		fq01[u]      = (y_re ^ (uint32_t)sx_re) - (uint32_t)sx_re;
		fq01[u + hn] = (y_im ^ (uint32_t)sx_im) - (uint32_t)sx_im;

#undef M
	}
	fx32_iFFT(logn, fq01);

#if HAWK_DEBUG
	printf("# fz = (q01*t1)/q00\n");
	print_i32(logn, "fz", (int32_t *)fq01);
#endif

	/*
	 * s0 <- round(h0/2 + (q01*t1)/q00)
	 * t0 <- h0 - 2*s0
	 * We also check that s0 is within the expected range; this is needed
	 * to verify that we do not lose information when writing the
	 * coefficients as int16_t, and also to ensure that the norm can be
	 * computed with the two moduli p1 and p2.
	 */
	int16_t *t0 = (int16_t *)tt32;
	int sh_s0 = sh_t1 + sh_q01 - sh_q00 - (logn - 1);
	int32_t lims0 = (int32_t)1 << bits_lims0[logn];
	for (size_t u = 0; u < n; u += 8) {
		uint32_t h0b = h[u >> 3];
		for (size_t v = 0; v < 8; v ++, h0b >>= 1) {
			uint32_t w = fx32_of(h0b & 1, sh_s0) + fq01[u + v];
			int32_t z = fx32_rint(w, sh_s0 + 1);
			if (z < -lims0 || z >= lims0) {
				return 0;
			}
			if (ss != NULL) {
				int16_t zz = (int16_t)z;
				memcpy((uint8_t *)ss + ((u + v) << 1), &zz, 2);
			}
			w = (h0b & 1) - ((uint32_t)z << 1);
			t0[u + v] = (int16_t)*(int32_t *)&w;
		}
	}

#if HAWK_DEBUG
	printf("# t0 = h0 - 2*s0\n");
	print_i16(logn, "t0", t0);
#endif

	/*
	 * At that point, we have t0 at the start of the temporary array.
	 * If s1, q00 and/or q01 were not provided in already decoded format,
	 * then they must be redecoded. t1 was also lost, so it is recomputed
	 * as t1 = h1 - 2*s1.
	 *
	 * The squared norm in base Q is such that:
	 *
	 *   n*sqnorm_Q(t) = Tr(q00*t0*adj(t0) + adj(q01)*t0*adj(t1)
	 *                      + q01*adj(t0)*t1 + q11*t1*adj(t1))
	 *
	 * The trace can be computed in NTT representation by simply
	 * adding the coefficients together.
	 *
	 * To perform the operation with minimal RAM usage, we rewrite the
	 * expression above into:
	 *
	 *   d = t1/q00
	 *   e = t0 + q01*d
	 *   n*sqnorm_Q(t) = Tr(q00*e*adj(e) + d*adj(t1))
	 *
	 * This works because q00*q11 = 1 + q01*adj(q01), and adj(q00) = q00.
	 *
	 * We must do the computation twice (modulo p1 and p2): thanks
	 * to the limits enforced on the coefficients of q00, q01, q11
	 * (at keygen), t0 and t1 (verified above), we know that the
	 * norm over the integers cannot exceed 15*2^58; since p1*p2 is
	 * larger than that bound, two moduli are enough.
	 */

	uint32_t *c1 = (uint32_t *)(t0 + n);
	uint32_t *c2 = c1 + n;
	int16_t *c1hi = (int16_t *)c1 + n;
	int16_t *c2hi = (int16_t *)c2 + n;

	uint32_t tnorm = 0;
	for (int i = 0; i < 2; i ++) {
		uint32_t p = (i == 0) ? P1 : P2;
		uint32_t p0i = (i == 0) ? P1_0i : P2_0i;
		uint32_t R3 = (i == 0) ? P1_R3 : P2_R3;
		uint32_t m16 = (i == 0) ? P1_m16 : P2_m16;
		const uint32_t *gm = (i == 0) ? GM_p1 : GM_p2;

		/* c2 <- t1 */
		if (sig_len == (size_t)-1) {
			memcpy(c2hi, s1, n * sizeof(int16_t));
		} else {
			(void)decode_s1(logn, c2hi, s1buf, s1buf_len);
		}
		make_t1(logn, c2hi, h + (n >> 3));
		mp_poly_to_NTT(logn, c2, c2hi, p, p0i, gm);

		/* c1 <- q00 (auto-adjoint) */
		if (pub_len != (size_t)-1) {
			q00 = c1hi;
			(void)decode_q00(logn, q00, q00buf, q00buf_len);
		}
		mp_poly_to_NTT_autoadj(logn, c1, q00, p, p0i, gm);

		/*
		 * c1 <- 1/c1
		 * We use Montgomery's trick to invert the n/2 values.
		 * For any x and y:
		 *   1/x = y*(1/(x*y)) 
		 *   1/y = x*(1/(x*y)) 
		 * Applied recursively, this allows inverting m values at
		 * the cost of a single true inversion, and 3*(m-1)
		 * much cheaper multiplications.
		 *
		 * This requires some temporary storage, but the upper
		 * half of c1[] is free at this point.
		 */
		uint32_t bx = c1[0];
		c1[hn] = bx;
		for (size_t u = 1; u < hn; u ++) {
			bx = mp_montymul(bx, c1[u], p, p0i);
			c1[u + hn] = bx;
		}
		bx = mp_div(1, bx, p, p0i, m16);
		for (size_t u = hn - 1; u > 0; u --) {
			uint32_t ix = mp_montymul(bx, c1[u + hn - 1], p, p0i);
			bx = mp_montymul(bx, c1[u], p, p0i);
			c1[u] = ix;
		}
		c1[0] = bx;

		/* c2 <- c2*c1 = t1/q00
		   nnacc = Tr_p(t1*adj(t1)/q00) */
		uint32_t nnacc = 0;
		for (size_t u = 0; u < hn; u ++) {
			uint32_t x1 = c2[u];
			uint32_t x2 = c2[(n - 1) - u];
			uint32_t qx = c1[u];
			x1 = mp_montymul(x1, qx, p, p0i);
			nnacc = mp_add(nnacc, mp_montymul(x1, x2, p, p0i), p);
			x2 = mp_montymul(x2, qx, p, p0i);
			c2[u] = x1;
			c2[(n - 1) - u] = x2;
		}
		/* nnacc is in double-anti-Montgomery representation
		   (i.e. divided by R = 2^64) */

		/* c1 <- q01 */
		if (pub_len != (size_t)-1) {
			q01 = c1hi;
			(void)decode_q01(logn, q01, q01buf, q01buf_len);
		}
		mp_poly_to_NTT(logn, c1, q01, p, p0i, gm);

		/* c1 <- c1*c2 = q01*t1/q00 */
		for (size_t u = 0; u < n; u ++) {
			c1[u] = mp_montymul(
				mp_montymul(c1[u], c2[u], p, p0i), R3, p, p0i);
		}

		/* c2 <- t0 */
		mp_poly_to_NTT(logn, c2, t0, p, p0i, gm);

		/* c2 <- c2 + c1 = t0 + q01*t1/q00 = e */
		for (size_t u = 0; u < n; u ++) {
			c2[u] = mp_add(c2[u], c1[u], p);
		}

		/* c1 <- q00 (auto-adjoint) */
		if (pub_len != (size_t)-1) {
			q00 = c1hi;
			(void)decode_q00(logn, q00, q00buf, q00buf_len);
		}
		mp_poly_to_NTT_autoadj(logn, c1, q00, p, p0i, gm);

		/* nnacc <- nnacc + Tr_p(c1*c2*adj(c2) = q00*e*adj(e)) */
		for (size_t u = 0; u < hn; u ++) {
			uint32_t x1 = c2[u];
			uint32_t x2 = c2[(n - 1) - u];
			uint32_t qx = c1[u];
			nnacc = mp_add(nnacc, mp_montymul(qx,
				mp_montymul(x1, x2, p, p0i), p, p0i), p);
		}

		/* nnacc is in double-anti-Montgomery representation;
		   convert it to normal representation */
		nnacc = mp_montymul(nnacc, R3, p, p0i);

		if (ss != NULL) {
			memcpy((uint8_t *)ss + 4 * n + 4 * i, &nnacc, 4);
		}

#if HAWK_DEBUG
		printf("# Qnorm(t)^2 mod %lu\n", (unsigned long)p);
		printf("qnt = %lu\n", (unsigned long)nnacc);
#endif

		if (i == 0) {
			tnorm = nnacc;
		} else {
			if (tnorm != nnacc) {
				/* Not the same value modulo p1 and p2;
				   thus, the value is greater than p2,
				   hence too large. */
				return 0;
			}
		}
	}

	/*
	 * We have (n*sqnorm_Q(t))/2 in tnorm (for each component of tnorm,
	 * we only used half of the coefficients, since adj(t)*Q*t is
	 * auto-adjoint). Signature is valid if:
	 *   sqnorm_Q(h/2 - s) <= (sigma_ver^2)*2*n
	 * since t = 2*(h/2 - s), we have sqnorm(t) = 4*sqnorm(h/2 - s).
	 * We thus need:
	 *   n*sqnorm_Q(t) <= (sigma_ver^2)*8*n^2
	 * i.e.:
	 *   tnorm <= (sigma_ver^2)*4*n^2
	 *
	 * Moreover, tnorm should be a multiple of 2^(n-1) at this point,
	 * since sqnorm_Q(t) is integral. We check this property as well;
	 * this allows expressing the bound as:
	 *   (tnorm >> (logn-1)) <= (sigma_ver^2)*8*n
	 */
	return (tnorm & (hn - 1)) == 0 && (tnorm >> (logn - 1)) <= max_tnorm;
}

/* see hawk.h */
int
Zh(verify_finish)(unsigned logn,
	const void *restrict sig, size_t sig_len,
	const shake_context *restrict sc_data,
	const void *restrict pub, size_t pub_len,
	void *restrict tmp, size_t tmp_len)
{
	/*
	 * Check degree and align temporary buffer.
	 */
	if (logn < 8 || logn > 10) {
		return 0;
	}
	if (tmp_len < 7) {
		return 0;
	}
	uintptr_t utmp1 = (uintptr_t)tmp;
	uintptr_t utmp2 = (utmp1 + 7) & ~(uintptr_t)7;
	tmp_len -= (size_t)(utmp2 - utmp1);
	uint32_t *tt32 = (void *)utmp2;

	/*
	 * If the signature and/or public key is in encoded format,
	 * try decoding it into the temporary buffer, if size allows.
	 * We also round up sizes to the next multiple of 32 bytes, to
	 * preserve 256-bit alignment, if any.
	 */
	size_t min_tmp_len = (size_t)10 << logn;
	if (pub_len != (size_t)-1) {
		size_t dpk_len = HAWK_DECODED_PUB_LENGTH(logn) << 1;
		dpk_len = (dpk_len + 31) & ~(size_t)31;
		if (tmp_len >= min_tmp_len + dpk_len) {
			int16_t *q00_q01_hpk = (int16_t *)tt32;
			tt32 = (uint32_t *)(q00_q01_hpk + (dpk_len >> 1));
			tmp_len -= dpk_len;
			if (Zh(decode_public_key)(logn, q00_q01_hpk,
				pub, pub_len) == 0)
			{
				return 0;
			}
			pub = q00_q01_hpk;
			pub_len = (size_t)-1;
		}
	}
	if (sig_len != (size_t)-1) {
		size_t dsig_len = HAWK_DECODED_SIG_LENGTH(logn) << 1;
		dsig_len = (dsig_len + 31) & ~(size_t)31;
		if (tmp_len >= min_tmp_len + dsig_len) {
			int16_t *s1_and_salt = (int16_t *)tt32;
			tt32 = (uint32_t *)(s1_and_salt + (dsig_len >> 1));
			tmp_len -= dsig_len;
			if (Zh(decode_signature)(logn, s1_and_salt,
				sig, sig_len) == 0)
			{
				return 0;
			}
			sig = s1_and_salt;
			sig_len = (size_t)-1;
		}
	}
	return Zh(verify_inner)(logn, sig, sig_len, sc_data,
		pub, pub_len, tt32, tmp_len, NULL);
}
